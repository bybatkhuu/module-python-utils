{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>'potato_util' is collection of simple useful utils package for python.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Python utilities</li> <li>Datetime utilities</li> <li>Generator utilities</li> <li>Sanitation utilities</li> <li>Security utilities</li> <li>Validation utilities</li> <li>HTTP utilities</li> <li>File I/O utilities</li> <li>And more...</li> </ul>"},{"location":"release-notes/","title":"\ud83d\udccc Release Notes","text":""},{"location":"release-notes/#v030-2026-02-04","title":"v0.3.0 (2026-02-04)","text":"<p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.2.1...v0.3.0</p>"},{"location":"release-notes/#v021-2026-02-04","title":"v0.2.1 (2026-02-04)","text":""},{"location":"release-notes/#whats-changed","title":"What's Changed","text":""},{"location":"release-notes/#features","title":"\u2728 Features","text":"<ul> <li>feat: add support for reading multiple config file formats asynchrono\u2026 by @bybatkhuu in https://github.com/bybatkhuu/module-python-utils/pull/12</li> </ul>"},{"location":"release-notes/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>chore(deps): update mkdocstrings[python] requirement from &lt;1.0.0,&gt;=0.24.3 to &gt;=0.24.3,&lt;2.0.0 by @dependabot[bot] in https://github.com/bybatkhuu/module-python-utils/pull/11</li> </ul> <p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.2.0...v0.2.1</p>"},{"location":"release-notes/#v020-2025-11-25","title":"v0.2.0 (2025-11-25)","text":""},{"location":"release-notes/#whats-changed_1","title":"What's Changed","text":""},{"location":"release-notes/#features_1","title":"\u2728 Features","text":"<ul> <li>feat: add async and sync functions to read YAML, JSON, TOML, and INI \u2026 by @bybatkhuu in https://github.com/bybatkhuu/module-python-utils/pull/9</li> </ul> <p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.1.0...v0.2.0</p>"},{"location":"release-notes/#v010-2025-11-23","title":"v0.1.0 (2025-11-23)","text":""},{"location":"release-notes/#whats-changed_2","title":"What's Changed","text":""},{"location":"release-notes/#features_2","title":"\u2728 Features","text":"<ul> <li>feat: add is_debug_mode function to check application debug status by @bybatkhuu in https://github.com/bybatkhuu/module-python-utils/pull/8</li> </ul>"},{"location":"release-notes/#dependencies_1","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>chore(deps): update aiofiles requirement from &lt;25.0.0,&gt;=24.1.0 to &gt;=24.1.0,&lt;26.0.0 by @dependabot[bot] in https://github.com/bybatkhuu/module-python-utils/pull/5</li> <li>chore(deps): update pylint requirement from &lt;4.0.0,&gt;=3.0.4 to &gt;=3.0.4,&lt;5.0.0 by @dependabot[bot] in https://github.com/bybatkhuu/module-python-utils/pull/6</li> <li>chore(deps): update pytest requirement from &lt;9.0.0,&gt;=8.0.2 to &gt;=8.0.2,&lt;10.0.0 by @dependabot[bot] in https://github.com/bybatkhuu/module-python-utils/pull/7</li> </ul>"},{"location":"release-notes/#new-contributors","title":"New Contributors","text":"<ul> <li>@dependabot[bot] made their first contribution in https://github.com/bybatkhuu/module-python-utils/pull/5</li> </ul> <p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.0.5...v0.1.0</p>"},{"location":"release-notes/#v005-2025-10-02","title":"v0.0.5 (2025-10-02)","text":""},{"location":"release-notes/#whats-changed_3","title":"What's Changed","text":""},{"location":"release-notes/#features_3","title":"\u2728 Features","text":"<ul> <li>feat: add get_slug_name function to slugify file names by @bybatkhuu in https://github.com/bybatkhuu/module-python-utils/pull/4</li> </ul> <p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.0.4...v0.0.5</p>"},{"location":"release-notes/#v004-2025-10-01","title":"v0.0.4 (2025-10-01)","text":"<p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.0.3...v0.0.4</p>"},{"location":"release-notes/#v003-2025-09-30","title":"v0.0.3 (2025-09-30)","text":""},{"location":"release-notes/#whats-changed_4","title":"What's Changed","text":""},{"location":"release-notes/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Update documentation, refactor potato_util module, and enhance error handling by @bybatkhuu in https://github.com/bybatkhuu/module-python-utils/pull/3</li> </ul> <p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.0.2...v0.0.3</p>"},{"location":"release-notes/#v002-2025-09-18","title":"v0.0.2 (2025-09-18)","text":"<p>Full Changelog: https://github.com/bybatkhuu/module-python-utils/compare/v0.0.1...v0.0.2</p>"},{"location":"about/authors/","title":"\ud83e\uddd9\u200d\u2642\ufe0f Authors","text":"<p>This project is developed by the following authors:</p> <ul> <li>@bybatkhuu - Batkhuu Byambajav</li> </ul>","tags":["about"]},{"location":"about/contact/","title":"\ud83d\udcde Contact","text":"<p>You can contact me by email at batkhuu10@gmail.com.</p>","tags":["about"]},{"location":"about/faq/","title":"\u2753 FAQ","text":"<p>This section contains frequently asked questions about this project.</p>","tags":["about"]},{"location":"about/faq/#q1-how-do-i-get-started-with-this-project","title":"Q1: How do I get started with this project?","text":"<p>To get started with this project, follow the instructions in the Getting Started guide.</p>","tags":["about"]},{"location":"about/license/","title":"\u00a9\ufe0f License","text":"<p>This project is licensed as the <code>LICENSE.md</code> file for details.</p>","tags":["about"]},{"location":"api-docs/dt/","title":"Datetime Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.calc_future_dt","title":"<code>calc_future_dt(delta, dt=None, tz=None)</code>","text":"<p>Calculate future datetime by adding delta time to current or specified datetime.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>(timedelta | int, required)</code> <p>Delta time to add to current or specified datetime.</p> required <code>dt</code> <code>datetime | None</code> <p>Datetime before adding delta time. Defaults to None.</p> <code>None</code> <code>tz</code> <code>(ZoneInfo | tzinfo, str, None)</code> <p>Timezone info. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Calculated future datetime.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call(config={\"arbitrary_types_allowed\": True})\ndef calc_future_dt(\n    delta: timedelta | int,\n    dt: datetime | None = None,\n    tz: ZoneInfo | tzinfo | str | None = None,\n) -&gt; datetime:\n    \"\"\"Calculate future datetime by adding delta time to current or specified datetime.\n\n    Args:\n        delta (timedelta | int             , required): Delta time to add to current or specified datetime.\n        dt    (datetime | None             , optional): Datetime before adding delta time. Defaults to None.\n        tz    (ZoneInfo | tzinfo, str, None, optional): Timezone info. Defaults to None.\n\n    Returns:\n        datetime: Calculated future datetime.\n    \"\"\"\n\n    if not dt:\n        dt = now_utc_dt()\n\n    if tz:\n        dt = convert_tz(dt=dt, tz=tz)\n\n    if isinstance(delta, int):\n        delta = timedelta(seconds=delta)\n\n    _future_dt = dt + delta\n    return _future_dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.convert_tz","title":"<code>convert_tz(dt, tz, warn_mode=WarnEnum.ALWAYS)</code>","text":"<p>Convert datetime object to another timezone.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>(datetime, required)</code> <p>Datetime object to convert.</p> required <code>tz</code> <code>(ZoneInfo | tzinfo | str, required)</code> <p>Timezone info to convert.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning mode. Defaults to WarnEnum.ALWAYS.</p> <code>ALWAYS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dt</code> argument doesn't have any timezone info and <code>warn_mode</code> is set to WarnEnum.ERROR.</p> <code>ValueError</code> <p>If <code>warn_mode</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Datetime object which has been converted to another timezone.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call(config={\"arbitrary_types_allowed\": True})\ndef convert_tz(\n    dt: datetime,\n    tz: ZoneInfo | tzinfo | str,\n    warn_mode: WarnEnum | str = WarnEnum.ALWAYS,\n) -&gt; datetime:\n    \"\"\"Convert datetime object to another timezone.\n\n    Args:\n        dt        (datetime               , required): Datetime object to convert.\n        tz        (ZoneInfo | tzinfo | str, required): Timezone info to convert.\n        warn_mode (WarnEnum | str         , optional): Warning mode. Defaults to WarnEnum.ALWAYS.\n\n    Raises:\n        ValueError: If `dt` argument doesn't have any timezone info and `warn_mode` is set to WarnEnum.ERROR.\n        ValueError: If `warn_mode` argument value is invalid.\n\n    Returns:\n        datetime: Datetime object which has been converted to another timezone.\n    \"\"\"\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if not dt.tzinfo:\n        _message = \"Not found any timezone info in `dt` argument, assuming it's UTC timezone...\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.warning(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n        elif warn_mode == WarnEnum.ERROR:\n            _message = \"Not found any timezone info in `dt` argument!\"\n            logger.error(_message)\n            raise ValueError(_message)\n\n        dt = replace_tz(dt=dt, tz=\"UTC\")\n\n    if isinstance(tz, str):\n        tz = ZoneInfo(tz)\n\n    dt = dt.astimezone(tz=tz)\n    return dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.dt_to_iso","title":"<code>dt_to_iso(dt, sep='T', warn_mode=WarnEnum.IGNORE)</code>","text":"<p>Convert datetime object to ISO 8601 format.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>(datetime, required)</code> <p>Datetime object.</p> required <code>sep</code> <code>str</code> <p>Separator between date and time. Defaults to \"T\".</p> <code>'T'</code> <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning mode. Defaults to WarnEnum.IGNORE.</p> <code>IGNORE</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dt</code> argument doesn't have any timezone info and <code>warn_mode</code> is set to WarnEnum.ERROR.</p> <code>ValueError</code> <p>If <code>sep</code> argument length is greater than 8.</p> <code>ValueError</code> <p>If <code>warn_mode</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Datetime string in ISO 8601 format.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call\ndef dt_to_iso(\n    dt: datetime, sep: str = \"T\", warn_mode: WarnEnum | str = WarnEnum.IGNORE\n) -&gt; str:\n    \"\"\"Convert datetime object to ISO 8601 format.\n\n    Args:\n        dt        (datetime      , required): Datetime object.\n        sep       (str           , optional): Separator between date and time. Defaults to \"T\".\n        warn_mode (WarnEnum | str, optional): Warning mode. Defaults to WarnEnum.IGNORE.\n\n    Raises:\n        ValueError: If `dt` argument doesn't have any timezone info and `warn_mode` is set to WarnEnum.ERROR.\n        ValueError: If `sep` argument length is greater than 8.\n        ValueError: If `warn_mode` argument value is invalid.\n\n    Returns:\n        str: Datetime string in ISO 8601 format.\n    \"\"\"\n\n    sep = sep.strip()\n    if 8 &lt; len(sep):\n        raise ValueError(\n            f\"`sep` argument length '{len(sep)}' is too long, must be less than or equal to 8!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if not dt.tzinfo:\n        _message = \"Not found any timezone info in `dt` argument, assuming it's UTC timezone...\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.warning(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n        elif warn_mode == WarnEnum.ERROR:\n            _message = \"Not found any timezone info in `dt` argument!\"\n            logger.error(_message)\n            raise ValueError(_message)\n\n        dt = replace_tz(dt=dt, tz=\"UTC\")\n\n    _dt_str = dt.isoformat(sep=sep, timespec=\"milliseconds\")\n    return _dt_str\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.dt_to_ts","title":"<code>dt_to_ts(dt, unit=TSUnitEnum.SECONDS)</code>","text":"<p>Convert datetime to timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>(datetime, required)</code> <p>Datetime object to convert.</p> required <code>unit</code> <code>TSUnitEnum | str</code> <p>Type of timestamp unit. Defaults to <code>TSUnitEnum.SECONDS</code>.</p> <code>SECONDS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>unit</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Converted timestamp.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call\ndef dt_to_ts(dt: datetime, unit: TSUnitEnum | str = TSUnitEnum.SECONDS) -&gt; int:\n    \"\"\"Convert datetime to timestamp.\n\n    Args:\n        dt   (datetime        , required): Datetime object to convert.\n        unit (TSUnitEnum | str, optional): Type of timestamp unit. Defaults to `TSUnitEnum.SECONDS`.\n\n    Raises:\n        ValueError: If `unit` argument value is invalid.\n\n    Returns:\n        int: Converted timestamp.\n    \"\"\"\n\n    _ts: int\n    if unit == TSUnitEnum.SECONDS:\n        _ts = int(dt.timestamp())\n    elif unit == TSUnitEnum.MILLISECONDS:\n        _ts = int(dt.timestamp() * 1000)\n    elif unit == TSUnitEnum.MICROSECONDS:\n        _ts = int(dt.timestamp() * 1000000)\n    elif unit == TSUnitEnum.NANOSECONDS:\n        _ts = int(dt.timestamp() * 1000000000)\n    else:\n        raise ValueError(f\"`unit` argument value '{unit}' is invalid!\")\n\n    return _ts\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.now_dt","title":"<code>now_dt(tz=None)</code>","text":"<p>Get current datetime in specified timezone with tzinfo.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>ZoneInfo | tzinfo | str | None</code> <p>Timezone info. Defaults to None (UTC timezone).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Current datetime in specified timezone with tzinfo.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call(config={\"arbitrary_types_allowed\": True})\ndef now_dt(tz: ZoneInfo | tzinfo | str | None = None) -&gt; datetime:\n    \"\"\"Get current datetime in specified timezone with tzinfo.\n\n    Args:\n        tz (ZoneInfo | tzinfo | str | None, optional): Timezone info. Defaults to None (UTC timezone).\n\n    Returns:\n        datetime: Current datetime in specified timezone with tzinfo.\n    \"\"\"\n\n    _dt = now_utc_dt()\n    if tz:\n        _dt = convert_tz(dt=_dt, tz=tz)\n    return _dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.now_local_dt","title":"<code>now_local_dt()</code>","text":"<p>Get current datetime in local timezone with tzinfo.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Current datetime in local timezone with tzinfo.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>def now_local_dt() -&gt; datetime:\n    \"\"\"Get current datetime in local timezone with tzinfo.\n\n    Returns:\n        datetime: Current datetime in local timezone with tzinfo.\n    \"\"\"\n\n    _local_dt = datetime.now().astimezone()\n    return _local_dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.now_ts","title":"<code>now_ts(unit=TSUnitEnum.SECONDS)</code>","text":"<p>Get current timestamp in UTC timezone.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>TSUnitEnum | str</code> <p>Type of timestamp unit. Defaults to TSUnitEnum.SECONDS.</p> <code>SECONDS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>unit</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Current timestamp.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call\ndef now_ts(unit: TSUnitEnum | str = TSUnitEnum.SECONDS) -&gt; int:\n    \"\"\"Get current timestamp in UTC timezone.\n\n    Args:\n        unit (TSUnitEnum | str, optional): Type of timestamp unit. Defaults to TSUnitEnum.SECONDS.\n\n    Raises:\n        ValueError: If `unit` argument value is invalid.\n\n    Returns:\n        int: Current timestamp.\n    \"\"\"\n\n    _now_ts: int\n    if unit == TSUnitEnum.SECONDS:\n        _now_ts = int(time.time())\n    elif unit == TSUnitEnum.MILLISECONDS:\n        _now_ts = int(time.time() * 1000)\n    elif unit == TSUnitEnum.MICROSECONDS:\n        _now_ts = int(time.time_ns() / 1000)\n    elif unit == TSUnitEnum.NANOSECONDS:\n        _now_ts = int(time.time_ns())\n    else:\n        raise ValueError(f\"`unit` argument value '{unit}' is invalid!\")\n\n    return _now_ts\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.now_utc_dt","title":"<code>now_utc_dt()</code>","text":"<p>Get current datetime in UTC timezone with tzinfo.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Current datetime in UTC timezone with tzinfo.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>def now_utc_dt() -&gt; datetime:\n    \"\"\"Get current datetime in UTC timezone with tzinfo.\n\n    Returns:\n        datetime: Current datetime in UTC timezone with tzinfo.\n    \"\"\"\n\n    _utc_dt = datetime.now(tz=timezone.utc)\n    return _utc_dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/dt/#src.potato_util.dt.replace_tz","title":"<code>replace_tz(dt, tz)</code>","text":"<p>Add or replace timezone info to datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>(datetime, required)</code> <p>Datetime object.</p> required <code>tz</code> <code>(ZoneInfo | tzinfo | str, required)</code> <p>Timezone info.</p> required <p>Raises:</p> Type Description <code>ZoneInfoNotFoundError</code> <p>If <code>tz</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Datetime object with timezone info.</p> Source code in <code>src/potato_util/dt.py</code> <pre><code>@validate_call(config={\"arbitrary_types_allowed\": True})\ndef replace_tz(dt: datetime, tz: ZoneInfo | tzinfo | str) -&gt; datetime:\n    \"\"\"Add or replace timezone info to datetime object.\n\n    Args:\n        dt (datetime               , required): Datetime object.\n        tz (ZoneInfo | tzinfo | str, required): Timezone info.\n\n    Raises:\n        ZoneInfoNotFoundError: If `tz` argument value is invalid.\n\n    Returns:\n        datetime: Datetime object with timezone info.\n    \"\"\"\n\n    if isinstance(tz, str):\n        tz = ZoneInfo(tz)\n\n    dt = dt.replace(tzinfo=tz)\n    return dt\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/generator/","title":"Generator Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/generator/#src.potato_util.generator.gen_random_string","title":"<code>gen_random_string(length=16, is_alphanum=True)</code>","text":"<p>Generate secure random string.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of random string. Defaults to 16.</p> <code>16</code> <code>is_alphanum</code> <code>bool</code> <p>If True, generate only alphanumeric string. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>length</code> is less than 1.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Generated random string.</p> Source code in <code>src/potato_util/generator.py</code> <pre><code>@validate_call\ndef gen_random_string(length: int = 16, is_alphanum: bool = True) -&gt; str:\n    \"\"\"Generate secure random string.\n\n    Args:\n        length      (int , optional): Length of random string. Defaults to 16.\n        is_alphanum (bool, optional): If True, generate only alphanumeric string. Defaults to True.\n\n    Raises:\n        ValueError: If `length` is less than 1.\n\n    Returns:\n        str: Generated random string.\n    \"\"\"\n\n    if length &lt; 1:\n        raise ValueError(\n            f\"`length` argument value {length} is too small, must be greater than or equal to 1!\",\n        )\n\n    _base_chars = string.ascii_letters + string.digits\n    if not is_alphanum:\n        _base_chars += string.punctuation\n\n    _random_str = \"\".join(secrets.choice(_base_chars) for _i in range(length))\n    return _random_str\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/generator/#src.potato_util.generator.gen_unique_id","title":"<code>gen_unique_id(prefix='')</code>","text":"<p>Generate unique ID. Format: '{prefix}{datetime}_{uuid4}'.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix of ID. Defaults to ''.</p> <code>''</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>prefix</code> length is greater than 32.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique ID.</p> Source code in <code>src/potato_util/generator.py</code> <pre><code>@validate_call\ndef gen_unique_id(prefix: str = \"\") -&gt; str:\n    \"\"\"Generate unique ID. Format: '{prefix}{datetime}_{uuid4}'.\n\n    Args:\n        prefix (str, optional): Prefix of ID. Defaults to ''.\n\n    Raises:\n        ValueError: If `prefix` length is greater than 32.\n\n    Returns:\n        str: Unique ID.\n    \"\"\"\n\n    prefix = prefix.strip()\n    if 32 &lt; len(prefix):\n        raise ValueError(\n            f\"`prefix` argument length {len(prefix)} is too long, must be less than or equal to 32!\",\n        )\n\n    _id = str(f\"{prefix}{now_ts()}_{uuid.uuid4().hex}\").lower()\n    return _id\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/http/","title":"HTTP Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/http/#src.potato_util.http.async_is_connectable","title":"<code>async_is_connectable(url=AnyHttpUrl('https://www.google.com'), timeout=3, check_status=False)</code>  <code>async</code>","text":"<p>Check if the url is connectable.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>AnyHttpUrl</code> <p>URL to check. Defaults to 'https://www.google.com'.</p> <code>AnyHttpUrl('https://www.google.com')</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 3.</p> <code>3</code> <code>check_status</code> <code>bool</code> <p>Check HTTP status code (200). Defaults to False.</p> <code>False</code> Raise <p>ValueError: If <code>timeout</code> is less than 1.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connectable, False otherwise.</p> Source code in <code>src/potato_util/http/_async.py</code> <pre><code>@validate_call\nasync def async_is_connectable(\n    url: AnyHttpUrl = AnyHttpUrl(\"https://www.google.com\"),\n    timeout: int = 3,\n    check_status: bool = False,\n) -&gt; bool:\n    \"\"\"Check if the url is connectable.\n\n    Args:\n        url          (AnyHttpUrl, optional): URL to check. Defaults to 'https://www.google.com'.\n        timeout      (int       , optional): Timeout in seconds. Defaults to 3.\n        check_status (bool      , optional): Check HTTP status code (200). Defaults to False.\n\n    Raise:\n        ValueError: If `timeout` is less than 1.\n\n    Returns:\n        bool: True if connectable, False otherwise.\n    \"\"\"\n\n    if timeout &lt; 1:\n        raise ValueError(\n            f\"`timeout` argument value {timeout} is invalid, must be greater than 0!\"\n        )\n\n    try:\n        async with aiohttp.ClientSession() as _session:\n            async with _session.get(str(url), timeout=timeout) as _response:\n                if check_status:\n                    return _response.status == 200\n                return True\n    except Exception:\n        return False\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/http/#src.potato_util.http.get_http_status","title":"<code>get_http_status(status_code)</code>","text":"<p>Get HTTP status code enum from integer value.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>(int, required)</code> <p>Status code for HTTP response: [100 &lt;= status_code &lt;= 599].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If status code is not in range [100 &lt;= status_code &lt;= 599].</p> <p>Returns:</p> Type Description <code>tuple[HTTPStatus, bool]</code> <p>Tuple[HTTPStatus, bool]: Tuple of HTTP status code enum and boolean value if status code is known.</p> Source code in <code>src/potato_util/http/_base.py</code> <pre><code>@validate_call\ndef get_http_status(status_code: int) -&gt; tuple[HTTPStatus, bool]:\n    \"\"\"Get HTTP status code enum from integer value.\n\n    Args:\n        status_code (int, required): Status code for HTTP response: [100 &lt;= status_code &lt;= 599].\n\n    Raises:\n        ValueError: If status code is not in range [100 &lt;= status_code &lt;= 599].\n\n    Returns:\n        Tuple[HTTPStatus, bool]: Tuple of HTTP status code enum and boolean value if status code is known.\n    \"\"\"\n\n    _http_status: HTTPStatus\n    _is_known_status = False\n    try:\n        _http_status = HTTPStatus(status_code)\n        _is_known_status = True\n    except ValueError:\n        if (100 &lt;= status_code) and (status_code &lt; 200):\n            status_code = 100\n        elif (200 &lt;= status_code) and (status_code &lt; 300):\n            status_code = 200\n        elif (300 &lt;= status_code) and (status_code &lt; 400):\n            status_code = 304\n        elif (400 &lt;= status_code) and (status_code &lt; 500):\n            status_code = 400\n        elif (500 &lt;= status_code) and (status_code &lt; 600):\n            status_code = 500\n        else:\n            raise ValueError(\n                f\"`status_code` argument value '{status_code}' is invalid, must be in range 100-599!\",\n            )\n\n        _http_status = HTTPStatus(status_code)\n\n    return (_http_status, _is_known_status)\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/http/#src.potato_util.http.is_connectable","title":"<code>is_connectable(url=AnyHttpUrl('https://www.google.com'), timeout=3, check_status=False)</code>","text":"<p>Check if the url is connectable.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>AnyHttpUrl</code> <p>URL to check. Defaults to 'https://www.google.com'.</p> <code>AnyHttpUrl('https://www.google.com')</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 3.</p> <code>3</code> <code>check_status</code> <code>bool</code> <p>Check HTTP status code (200). Defaults to False.</p> <code>False</code> Raise <p>ValueError: If <code>timeout</code> is less than 1.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connectable, False otherwise.</p> Source code in <code>src/potato_util/http/_sync.py</code> <pre><code>@validate_call\ndef is_connectable(\n    url: AnyHttpUrl = AnyHttpUrl(\"https://www.google.com\"),\n    timeout: int = 3,\n    check_status: bool = False,\n) -&gt; bool:\n    \"\"\"Check if the url is connectable.\n\n    Args:\n        url          (AnyHttpUrl, optional): URL to check. Defaults to 'https://www.google.com'.\n        timeout      (int       , optional): Timeout in seconds. Defaults to 3.\n        check_status (bool      , optional): Check HTTP status code (200). Defaults to False.\n\n    Raise:\n        ValueError: If `timeout` is less than 1.\n\n    Returns:\n        bool: True if connectable, False otherwise.\n    \"\"\"\n\n    if timeout &lt; 1:\n        raise ValueError(\n            f\"`timeout` argument value {timeout} is invalid, must be greater than 0!\"\n        )\n\n    try:\n        _response: HTTPResponse = request.urlopen(\n            str(url), timeout=timeout\n        )  # nosec B310\n        if check_status:\n            return _response.getcode() == 200\n        return True\n    except Exception:\n        return False\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/","title":"IO Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_create_dir","title":"<code>async_create_dir(create_dir, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous create directory if <code>create_dir</code> doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>create_dir</code> <code>(str, required)</code> <p>Create directory path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>create_dir</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and directory already exists.</p> <code>OSError</code> <p>If failed to create directory.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_create_dir(\n    create_dir: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Asynchronous create directory if `create_dir` doesn't exist.\n\n    Args:\n        create_dir (str           , required): Create directory path.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `create_dir` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and directory already exists.\n        OSError   : If failed to create directory.\n    \"\"\"\n\n    create_dir = create_dir.strip()\n    if (len(create_dir) &lt; 1) or (MAX_PATH_LENGTH &lt; len(create_dir)):\n        raise ValueError(\n            f\"`create_dir` argument length {len(create_dir)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if not await aiofiles.os.path.isdir(create_dir):\n        try:\n            _message = f\"Creating '{create_dir}' directory...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            await aiofiles.os.makedirs(create_dir)\n        except OSError as err:\n            if (err.errno == errno.EEXIST) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{create_dir}' directory already exists!\")\n            else:\n                logger.error(f\"Failed to create '{create_dir}' directory!\")\n                raise\n\n        _message = f\"Successfully created '{create_dir}' directory.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.EEXIST, f\"'{create_dir}' directory already exists!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_get_file_checksum","title":"<code>async_get_file_checksum(file_path, hash_method=HashAlgoEnum.md5, chunk_size=4096, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous get file checksum.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str, required)</code> <p>Target file path.</p> required <code>hash_method</code> <code>HashAlgoEnum</code> <p>Hash method. Defaults to <code>HashAlgoEnum.md5</code>.</p> <code>md5</code> <code>chunk_size</code> <code>int</code> <p>Chunk size. Defaults to 4096.</p> <code>4096</code> <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                         Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_path</code> argument length is out of range.</p> <code>ValueError</code> <p>If <code>chunk_size</code> argument value is invalid.</p> <code>OSError</code> <p>When warning mode is set to ERROR and file doesn't exist.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: File checksum or None if file doesn't exist.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_get_file_checksum(\n    file_path: str,\n    hash_method: HashAlgoEnum = HashAlgoEnum.md5,\n    chunk_size: int = 4096,\n    warn_mode: WarnEnum | str = WarnEnum.DEBUG,\n) -&gt; str | None:\n    \"\"\"Asynchronous get file checksum.\n\n    Args:\n        file_path   (str           , required): Target file path.\n        hash_method (HashAlgoEnum  , optional): Hash method. Defaults to `HashAlgoEnum.md5`.\n        chunk_size  (int           , optional): Chunk size. Defaults to 4096.\n        warn_mode   (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                    Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `file_path` argument length is out of range.\n        ValueError: If `chunk_size` argument value is invalid.\n        OSError   : When warning mode is set to ERROR and file doesn't exist.\n\n    Returns:\n        str | None: File checksum or None if file doesn't exist.\n    \"\"\"\n\n    file_path = file_path.strip()\n    if (len(file_path) &lt; 1) or (MAX_PATH_LENGTH &lt; len(file_path)):\n        raise ValueError(\n            f\"`file_path` argument length {len(file_path)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if chunk_size &lt; 10:\n        raise ValueError(\n            f\"`chunk_size` argument value {chunk_size} is invalid, must be greater than 10!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    _file_checksum: str | None = None\n    if await aiofiles.os.path.isfile(file_path):\n        _file_hash = hashlib.new(hash_method.value)\n        async with aiofiles.open(file_path, \"rb\") as _file:\n            while True:\n                _file_chunk = await _file.read(chunk_size)\n                if not _file_chunk:\n                    break\n                _file_hash.update(_file_chunk)\n\n        _file_checksum = _file_hash.hexdigest()\n    else:\n        _message = f\"'{file_path}' file doesn't exist!\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.warning(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n        elif warn_mode == WarnEnum.ERROR:\n            raise OSError(errno.ENOENT, _message)\n\n    return _file_checksum\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_all_configs","title":"<code>async_read_all_configs(configs_dir, allowed_formats=[ConfigFileFormatEnum.YAML, ConfigFileFormatEnum.JSON, ConfigFileFormatEnum.TOML])</code>  <code>async</code>","text":"<p>Asynchronous read all config files from directory or directories and merge them.</p> <p>Parameters:</p> Name Type Description Default <code>configs_dir</code> <code>(str | Path | list[str | Path], required)</code> <p>Configs directory or directories.</p> required <code>allowed_formats</code> <code>list[ConfigFileFormatEnum]</code> <p>Allowed config file formats to read.                                                         Defaults to [YAML, JSON, TOML].</p> <code>[YAML, JSON, TOML]</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing all merged config data from all files.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_all_configs(\n    configs_dir: str | Path | list[str | Path],\n    allowed_formats: list[ConfigFileFormatEnum] = [\n        ConfigFileFormatEnum.YAML,\n        ConfigFileFormatEnum.JSON,\n        ConfigFileFormatEnum.TOML,\n    ],\n) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read all config files from directory or directories and merge them.\n\n    Args:\n        configs_dir     (str | Path | list[str | Path], required): Configs directory or directories.\n        allowed_formats (list[ConfigFileFormatEnum]   , optional): Allowed config file formats to read.\n                                                                    Defaults to [YAML, JSON, TOML].\n\n    Returns:\n        dict[str, Any]: Dictionary containing all merged config data from all files.\n    \"\"\"\n\n    _config_dict: dict[str, Any] = {}\n\n    if not isinstance(configs_dir, list):\n        configs_dir = [configs_dir]\n\n    _file_paths: list[str] = []\n    for _config_dir in configs_dir:\n        if isinstance(_config_dir, str):\n            _config_dir = Path(_config_dir)\n\n        if not os.path.isabs(_config_dir):\n            _current_dir = await aiofiles.os.getcwd()\n            _config_dir = os.path.join(_current_dir, _config_dir)\n\n        if await aiofiles.os.path.isdir(_config_dir):\n            if ConfigFileFormatEnum.YAML in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.yaml\")))\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.yml\")))\n\n            if ConfigFileFormatEnum.JSON in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.json\")))\n\n            if ConfigFileFormatEnum.TOML in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.toml\")))\n\n            if ConfigFileFormatEnum.INI in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.ini\")))\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.cfg\")))\n\n    _file_paths.sort()\n    for _file_path in _file_paths:\n        _config_data = await async_read_config_file(config_path=_file_path)\n        _config_dict = deep_merge(_config_dict, _config_data)\n\n    return _config_dict\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_config_file","title":"<code>async_read_config_file(config_path)</code>  <code>async</code>","text":"<p>Asynchronous read config file (YAML, JSON, TOML, INI).</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>(str | Path, required)</code> <p>Config file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If config file is not found.</p> <code>ValueError</code> <p>If config file format is not supported.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Config file data as dictionary.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_config_file(config_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read config file (YAML, JSON, TOML, INI).\n\n    Args:\n        config_path (str | Path, required): Config file path.\n\n    Raises:\n        FileNotFoundError: If config file is not found.\n        ValueError        : If config file format is not supported.\n\n    Returns:\n        dict[str, Any]: Config file data as dictionary.\n    \"\"\"\n\n    _config: dict[str, Any] = {}\n\n    if isinstance(config_path, str):\n        config_path = Path(config_path)\n\n    if not await aiofiles.os.path.isfile(config_path):\n        raise FileNotFoundError(f\"Not found '{config_path}' config file!\")\n\n    _suffix = config_path.suffix.lower()\n    if _suffix in (\".yaml\", \".yml\"):\n        _config = await async_read_yaml_file(config_path)\n    elif _suffix == \".json\":\n        _config = await async_read_json_file(config_path)\n    elif _suffix == \".toml\":\n        _config = await async_read_toml_file(config_path)\n    elif _suffix in (\".ini\", \".cfg\"):\n        _config = await async_read_ini_file(config_path)\n    else:\n        raise ValueError(\n            f\"Unsupported config file format '{_suffix}' for '{config_path}'!\"\n        )\n\n    return _config\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_ini_file","title":"<code>async_read_ini_file(file_path)</code>  <code>async</code>","text":"<p>Asynchronous read INI config file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>INI config file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If INI config file is not found.</p> <code>Exception</code> <p>If failed to read INI config file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: INI config file data as dictionary.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_ini_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read INI config file.\n\n    Args:\n        file_path (str | Path, required): INI config file path.\n\n    Raises:\n        FileNotFoundError: If INI config file is not found.\n        Exception        : If failed to read INI config file.\n\n    Returns:\n        dict[str, Any]: INI config file data as dictionary.\n    \"\"\"\n\n    _config: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not await aiofiles.os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' INI config file!\")\n\n    try:\n        _content: str = \"\"\n        async with aiofiles.open(file_path, \"r\", encoding=\"utf-8\") as _file:\n            _content = await _file.read()\n\n        _config_parser = configparser.ConfigParser()\n        _config_parser.read_string(_content)\n        for _section in _config_parser.sections():\n            _config[_section] = dict(_config_parser.items(_section))\n\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' INI config file!\")\n        raise\n\n    return _config\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_json_file","title":"<code>async_read_json_file(file_path)</code>  <code>async</code>","text":"<p>Asynchronous read JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>JSON file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If JSON file is not found.</p> <code>Exception</code> <p>If failed to read JSON file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: JSON file data as dictionary.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_json_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read JSON file.\n\n    Args:\n        file_path (str | Path, required): JSON file path.\n\n    Raises:\n        FileNotFoundError: If JSON file is not found.\n        Exception        : If failed to read JSON file.\n\n    Returns:\n        dict[str, Any]: JSON file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not await aiofiles.os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' JSON file!\")\n\n    try:\n        async with aiofiles.open(file_path, \"r\", encoding=\"utf-8\") as _file:\n            _content = await _file.read()\n            _data = json.loads(_content) or {}\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' JSON file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_toml_file","title":"<code>async_read_toml_file(file_path)</code>  <code>async</code>","text":"<p>Asynchronous read TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>TOML file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If TOML file is not found.</p> <code>Exception</code> <p>If failed to read TOML file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: TOML file data as dictionary.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_toml_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read TOML file.\n\n    Args:\n        file_path (str | Path, required): TOML file path.\n\n    Raises:\n        FileNotFoundError: If TOML file is not found.\n        Exception        : If failed to read TOML file.\n\n    Returns:\n        dict[str, Any]: TOML file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not await aiofiles.os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' TOML file!\")\n\n    try:\n        _content: str = \"\"\n        if _binary_toml:\n            async with aiofiles.open(file_path, \"rb\") as _file:\n                _content = await _file.read()  # type: ignore\n                _data = tomllib.load(_content) or {}\n        else:\n            async with aiofiles.open(file_path, \"r\", encoding=\"utf-8\") as _file:\n                _content = await _file.read()  # type: ignore\n                _data = tomllib.loads(_content) or {}\n\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' TOML file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_read_yaml_file","title":"<code>async_read_yaml_file(file_path)</code>  <code>async</code>","text":"<p>Asynchronous read YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>YAML file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If YAML file is not found.</p> <code>Exception</code> <p>If failed to read YAML file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: YAML file data as dictionary.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_read_yaml_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Asynchronous read YAML file.\n\n    Args:\n        file_path (str | Path, required): YAML file path.\n\n    Raises:\n        FileNotFoundError: If YAML file is not found.\n        Exception        : If failed to read YAML file.\n\n    Returns:\n        dict[str, Any]: YAML file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not await aiofiles.os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' YAML file!\")\n\n    try:\n        async with aiofiles.open(file_path, \"r\", encoding=\"utf-8\") as _file:\n            _content = await _file.read()\n            _data = yaml.safe_load(_content) or {}\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' YAML file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_remove_dir","title":"<code>async_remove_dir(remove_dir, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous remove directory if <code>remove_dir</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>remove_dir</code> <code>(str, required)</code> <p>Remove directory path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>remove_dir</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and directory doesn't exist.</p> <code>OSError</code> <p>If failed to remove directory.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_remove_dir(\n    remove_dir: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Asynchronous remove directory if `remove_dir` exists.\n\n    Args:\n        remove_dir (str           , required): Remove directory path.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `remove_dir` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and directory doesn't exist.\n        OSError   : If failed to remove directory.\n    \"\"\"\n\n    remove_dir = remove_dir.strip()\n    if (len(remove_dir) &lt; 1) or (MAX_PATH_LENGTH &lt; len(remove_dir)):\n        raise ValueError(\n            f\"`remove_dir` argument length {len(remove_dir)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if await aiofiles.os.path.isdir(remove_dir):\n        try:\n            _message = f\"Removing '{remove_dir}' directory...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            await aioshutil.rmtree(remove_dir)\n        except OSError as err:\n            if (err.errno == errno.ENOENT) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{remove_dir}' directory doesn't exist!\")\n            else:\n                logger.error(f\"Failed to remove '{remove_dir}' directory!\")\n                raise\n\n        _message = f\"Successfully removed '{remove_dir}' directory.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.ENOENT, f\"'{remove_dir}' directory doesn't exist!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_remove_dirs","title":"<code>async_remove_dirs(remove_dirs, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous remove directories if <code>remove_dirs</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>remove_dirs</code> <code>(list[str], required)</code> <p>Remove directories paths as list.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                         Defaults to 'DEBUG'.</p> <code>DEBUG</code> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_remove_dirs(\n    remove_dirs: list[str], warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Asynchronous remove directories if `remove_dirs` exists.\n\n    Args:\n        remove_dirs (list[str]     , required): Remove directories paths as list.\n        warn_mode   (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                    Defaults to 'DEBUG'.\n    \"\"\"\n\n    for _remove_dir in remove_dirs:\n        await async_remove_dir(remove_dir=_remove_dir, warn_mode=warn_mode)\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_remove_file","title":"<code>async_remove_file(file_path, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous remove file if <code>file_path</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str, required)</code> <p>Remove file path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_path</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and file doesn't exist.</p> <code>OSError</code> <p>If failed to remove file.</p> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_remove_file(\n    file_path: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Asynchronous remove file if `file_path` exists.\n\n    Args:\n        file_path (str           , required): Remove file path.\n        warn_mode (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `file_path` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and file doesn't exist.\n        OSError   : If failed to remove file.\n    \"\"\"\n\n    file_path = file_path.strip()\n    if (len(file_path) &lt; 1) or (MAX_PATH_LENGTH &lt; len(file_path)):\n        raise ValueError(\n            f\"`file_path` argument length {len(file_path)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if await aiofiles.os.path.isfile(file_path):\n        try:\n            _message = f\"Removing '{file_path}' file...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            await aiofiles.os.remove(file_path)\n        except OSError as err:\n            if (err.errno == errno.ENOENT) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{file_path}' file doesn't exist!\")\n            else:\n                logger.error(f\"Failed to remove '{file_path}' file!\")\n                raise\n\n        _message = f\"Successfully removed '{file_path}' file.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.ENOENT, f\"'{file_path}' file doesn't exist!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.async_remove_files","title":"<code>async_remove_files(file_paths, warn_mode=WarnEnum.DEBUG)</code>  <code>async</code>","text":"<p>Asynchronous remove files if <code>file_paths</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>(list[str], required)</code> <p>Remove file paths as list.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> Source code in <code>src/potato_util/io/_async.py</code> <pre><code>@validate_call\nasync def async_remove_files(\n    file_paths: list[str], warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Asynchronous remove files if `file_paths` exists.\n\n    Args:\n        file_paths (list[str]     , required): Remove file paths as list.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n    \"\"\"\n\n    for _file_path in file_paths:\n        await async_remove_file(file_path=_file_path, warn_mode=warn_mode)\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.create_dir","title":"<code>create_dir(create_dir, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Create directory if <code>create_dir</code> doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>create_dir</code> <code>(str, required)</code> <p>Create directory path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>create_dir</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and directory already exists.</p> <code>OSError</code> <p>If failed to create directory.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef create_dir(create_dir: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG) -&gt; None:\n    \"\"\"Create directory if `create_dir` doesn't exist.\n\n    Args:\n        create_dir (str           , required): Create directory path.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `create_dir` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and directory already exists.\n        OSError   : If failed to create directory.\n    \"\"\"\n\n    create_dir = create_dir.strip()\n    if (len(create_dir) &lt; 1) or (MAX_PATH_LENGTH &lt; len(create_dir)):\n        raise ValueError(\n            f\"`create_dir` argument length {len(create_dir)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if not os.path.isdir(create_dir):\n        try:\n            _message = f\"Creating '{create_dir}' directory...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            os.makedirs(create_dir)\n        except OSError as err:\n            if (err.errno == errno.EEXIST) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{create_dir}' directory already exists!\")\n            else:\n                logger.error(f\"Failed to create '{create_dir}' directory!\")\n                raise\n\n        _message = f\"Successfully created '{create_dir}' directory.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.EEXIST, f\"'{create_dir}' directory already exists!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.get_file_checksum","title":"<code>get_file_checksum(file_path, hash_method=HashAlgoEnum.md5, chunk_size=4096, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Get file checksum.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str, required)</code> <p>Target file path.</p> required <code>hash_method</code> <code>HashAlgoEnum</code> <p>Hash method. Defaults to <code>HashAlgoEnum.md5</code>.</p> <code>md5</code> <code>chunk_size</code> <code>int</code> <p>Chunk size. Defaults to 4096.</p> <code>4096</code> <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                         Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_path</code> argument length is out of range.</p> <code>ValueError</code> <p>If <code>chunk_size</code> argument value is invalid.</p> <code>OSError</code> <p>When warning mode is set to ERROR and file doesn't exist.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: File checksum or None if file doesn't exist.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef get_file_checksum(\n    file_path: str,\n    hash_method: HashAlgoEnum = HashAlgoEnum.md5,\n    chunk_size: int = 4096,\n    warn_mode: WarnEnum | str = WarnEnum.DEBUG,\n) -&gt; str | None:\n    \"\"\"Get file checksum.\n\n    Args:\n        file_path   (str           , required): Target file path.\n        hash_method (HashAlgoEnum  , optional): Hash method. Defaults to `HashAlgoEnum.md5`.\n        chunk_size  (int           , optional): Chunk size. Defaults to 4096.\n        warn_mode   (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                    Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `file_path` argument length is out of range.\n        ValueError: If `chunk_size` argument value is invalid.\n        OSError   : When warning mode is set to ERROR and file doesn't exist.\n\n    Returns:\n        str | None: File checksum or None if file doesn't exist.\n    \"\"\"\n\n    file_path = file_path.strip()\n    if (len(file_path) &lt; 1) or (MAX_PATH_LENGTH &lt; len(file_path)):\n        raise ValueError(\n            f\"`file_path` argument length {len(file_path)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if chunk_size &lt; 10:\n        raise ValueError(\n            f\"`chunk_size` argument value {chunk_size} is invalid, must be greater than 10!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    _file_checksum: str | None = None\n    if os.path.isfile(file_path):\n        _file_hash = hashlib.new(hash_method.value)\n        with open(file_path, \"rb\") as _file:\n            while True:\n                _file_chunk = _file.read(chunk_size)\n                if not _file_chunk:\n                    break\n                _file_hash.update(_file_chunk)\n\n        _file_checksum = _file_hash.hexdigest()\n    else:\n        _message = f\"'{file_path}' file doesn't exist!\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.warning(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n        elif warn_mode == WarnEnum.ERROR:\n            raise OSError(errno.ENOENT, _message)\n\n    return _file_checksum\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_all_configs","title":"<code>read_all_configs(configs_dir, allowed_formats=[ConfigFileFormatEnum.YAML, ConfigFileFormatEnum.JSON, ConfigFileFormatEnum.TOML])</code>","text":"<p>Read all config files from directory or directories and merge them.</p> <p>Parameters:</p> Name Type Description Default <code>configs_dir</code> <code>(str | Path | list[str | Path], required)</code> <p>Configs directory or directories.</p> required <code>allowed_formats</code> <code>list[ConfigFileFormatEnum]</code> <p>Allowed config file formats to read.                                                         Defaults to [YAML, JSON, TOML].</p> <code>[YAML, JSON, TOML]</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing all merged config data from all files.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_all_configs(\n    configs_dir: str | Path | list[str | Path],\n    allowed_formats: list[ConfigFileFormatEnum] = [\n        ConfigFileFormatEnum.YAML,\n        ConfigFileFormatEnum.JSON,\n        ConfigFileFormatEnum.TOML,\n    ],\n) -&gt; dict[str, Any]:\n    \"\"\"Read all config files from directory or directories and merge them.\n\n    Args:\n        configs_dir     (str | Path | list[str | Path], required): Configs directory or directories.\n        allowed_formats (list[ConfigFileFormatEnum]   , optional): Allowed config file formats to read.\n                                                                    Defaults to [YAML, JSON, TOML].\n\n    Returns:\n        dict[str, Any]: Dictionary containing all merged config data from all files.\n    \"\"\"\n\n    _config_dict: dict[str, Any] = {}\n\n    if not isinstance(configs_dir, list):\n        configs_dir = [configs_dir]\n\n    _file_paths: list[str] = []\n    for _config_dir in configs_dir:\n        if isinstance(_config_dir, str):\n            _config_dir = Path(_config_dir)\n\n        if not os.path.isabs(_config_dir):\n            _current_dir = os.getcwd()\n            _config_dir = os.path.join(_current_dir, _config_dir)\n\n        if os.path.isdir(_config_dir):\n            if ConfigFileFormatEnum.YAML in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.yaml\")))\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.yml\")))\n\n            if ConfigFileFormatEnum.JSON in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.json\")))\n\n            if ConfigFileFormatEnum.TOML in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.toml\")))\n\n            if ConfigFileFormatEnum.INI in allowed_formats:\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.ini\")))\n                _file_paths.extend(glob.glob(os.path.join(_config_dir, \"*.cfg\")))\n\n    _file_paths.sort()\n    for _file_path in _file_paths:\n        _config_data = read_config_file(config_path=_file_path)\n        _config_dict = deep_merge(_config_dict, _config_data)\n\n    return _config_dict\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_config_file","title":"<code>read_config_file(config_path)</code>","text":"<p>Read config file (YAML, JSON, TOML, INI).</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>(str | Path, required)</code> <p>Config file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If config file is not found.</p> <code>ValueError</code> <p>If config file format is not supported.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Config file data as dictionary.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_config_file(config_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Read config file (YAML, JSON, TOML, INI).\n\n    Args:\n        config_path (str | Path, required): Config file path.\n\n    Raises:\n        FileNotFoundError: If config file is not found.\n        ValueError       : If config file format is not supported.\n\n    Returns:\n        dict[str, Any]: Config file data as dictionary.\n    \"\"\"\n\n    _config: dict[str, Any] = {}\n\n    if isinstance(config_path, str):\n        config_path = Path(config_path)\n\n    if not os.path.isfile(config_path):\n        raise FileNotFoundError(f\"Not found '{config_path}' config file!\")\n\n    _suffix = config_path.suffix.lower()\n    if _suffix in (\".yaml\", \".yml\"):\n        _config = read_yaml_file(file_path=config_path)\n    elif _suffix == \".json\":\n        _config = read_json_file(file_path=config_path)\n    elif _suffix == \".toml\":\n        _config = read_toml_file(file_path=config_path)\n    elif _suffix in (\".ini\", \".cfg\"):\n        _config = read_ini_file(file_path=config_path)\n    else:\n        raise ValueError(\n            f\"Unsupported config file format '{config_path.suffix}' for '{config_path}'!\"\n        )\n\n    return _config\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_ini_file","title":"<code>read_ini_file(file_path)</code>","text":"<p>Read INI config file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>INI config file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If INI config file is not found.</p> <code>Exception</code> <p>If failed to read INI config file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: INI config file data as dictionary.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_ini_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Read INI config file.\n\n    Args:\n        file_path (str | Path, required): INI config file path.\n\n    Raises:\n        FileNotFoundError: If INI config file is not found.\n        Exception        : If failed to read INI config file.\n\n    Returns:\n        dict[str, Any]: INI config file data as dictionary.\n    \"\"\"\n\n    _config: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' INI config file!\")\n\n    try:\n        _config_parser = configparser.ConfigParser()\n        _config_parser.read(file_path)\n        for _section in _config_parser.sections():\n            _config[_section] = dict(_config_parser.items(_section))\n\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' INI config file!\")\n        raise\n\n    return _config\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_json_file","title":"<code>read_json_file(file_path)</code>","text":"<p>Read JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>JSON file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If JSON file is not found.</p> <code>Exception</code> <p>If failed to read JSON file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: JSON file data as dictionary.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_json_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Read JSON file.\n\n    Args:\n        file_path (str | Path, required): JSON file path.\n\n    Raises:\n        FileNotFoundError: If JSON file is not found.\n        Exception        : If failed to read JSON file.\n\n    Returns:\n        dict[str, Any]: JSON file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' JSON file!\")\n\n    try:\n        with open(file_path, encoding=\"utf-8\") as _file:\n            _data = json.load(_file) or {}\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' JSON file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_toml_file","title":"<code>read_toml_file(file_path)</code>","text":"<p>Read TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>TOML file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If TOML file is not found.</p> <code>Exception</code> <p>If failed to read TOML file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: TOML file data as dictionary.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_toml_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Read TOML file.\n\n    Args:\n        file_path (str | Path, required): TOML file path.\n\n    Raises:\n        FileNotFoundError: If TOML file is not found.\n        Exception        : If failed to read TOML file.\n\n    Returns:\n        dict[str, Any]: TOML file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' TOML file!\")\n\n    try:\n        if _binary_toml:\n            with open(file_path, \"rb\") as _file:\n                _data = tomllib.load(_file) or {}  # type: ignore\n        else:\n            with open(file_path, encoding=\"utf-8\") as _file:\n                _data = tomllib.load(_file) or {}  # type: ignore\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' TOML file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.read_yaml_file","title":"<code>read_yaml_file(file_path)</code>","text":"<p>Read YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str | Path, required)</code> <p>YAML file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If YAML file is not found.</p> <code>Exception</code> <p>If failed to read YAML file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: YAML file data as dictionary.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef read_yaml_file(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Read YAML file.\n\n    Args:\n        file_path (str | Path, required): YAML file path.\n\n    Raises:\n        FileNotFoundError: If YAML file is not found.\n        Exception        : If failed to read YAML file.\n\n    Returns:\n        dict[str, Any]: YAML file data as dictionary.\n    \"\"\"\n\n    _data: dict[str, Any] = {}\n\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Not found '{file_path}' YAML file!\")\n\n    try:\n        with open(file_path, encoding=\"utf-8\") as _file:\n            _data = yaml.safe_load(_file) or {}\n    except Exception:\n        logger.error(f\"Failed to read '{file_path}' YAML file!\")\n        raise\n\n    return _data\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.remove_dir","title":"<code>remove_dir(remove_dir, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Remove directory if <code>remove_dir</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>remove_dir</code> <code>(str, required)</code> <p>Remove directory path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>remove_dir</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and directory doesn't exist.</p> <code>OSError</code> <p>If failed to remove directory.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef remove_dir(remove_dir: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG) -&gt; None:\n    \"\"\"Remove directory if `remove_dir` exists.\n\n    Args:\n        remove_dir (str           , required): Remove directory path.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `remove_dir` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and directory doesn't exist.\n        OSError   : If failed to remove directory.\n    \"\"\"\n\n    remove_dir = remove_dir.strip()\n    if (len(remove_dir) &lt; 1) or (MAX_PATH_LENGTH &lt; len(remove_dir)):\n        raise ValueError(\n            f\"`remove_dir` argument length {len(remove_dir)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if os.path.isdir(remove_dir):\n        try:\n            _message = f\"Removing '{remove_dir}' directory...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            shutil.rmtree(remove_dir)\n        except OSError as err:\n            if (err.errno == errno.ENOENT) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{remove_dir}' directory doesn't exist!\")\n            else:\n                logger.error(f\"Failed to remove '{remove_dir}' directory!\")\n                raise\n\n        _message = f\"Successfully removed '{remove_dir}' directory.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.ENOENT, f\"'{remove_dir}' directory doesn't exist!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.remove_dirs","title":"<code>remove_dirs(remove_dirs, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Remove directories if <code>remove_dirs</code> exist.</p> <p>Parameters:</p> Name Type Description Default <code>remove_dirs</code> <code>(list[str], required)</code> <p>Remove directory paths as list.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef remove_dirs(\n    remove_dirs: list[str], warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Remove directories if `remove_dirs` exist.\n\n    Args:\n        remove_dirs (list[str]     , required): Remove directory paths as list.\n        warn_mode   (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n    \"\"\"\n\n    for _remove_dir in remove_dirs:\n        remove_dir(remove_dir=_remove_dir, warn_mode=warn_mode)\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.remove_file","title":"<code>remove_file(file_path, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Remove file if <code>file_path</code> exists.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str, required)</code> <p>Remove file path.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_path</code> argument length is out of range.</p> <code>OSError</code> <p>When warning mode is set to ERROR and file doesn't exist.</p> <code>OSError</code> <p>If failed to remove file.</p> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef remove_file(file_path: str, warn_mode: WarnEnum | str = WarnEnum.DEBUG) -&gt; None:\n    \"\"\"Remove file if `file_path` exists.\n\n    Args:\n        file_path (str           , required): Remove file path.\n        warn_mode (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n\n    Raises:\n        ValueError: If `file_path` argument length is out of range.\n        OSError   : When warning mode is set to ERROR and file doesn't exist.\n        OSError   : If failed to remove file.\n    \"\"\"\n\n    file_path = file_path.strip()\n    if (len(file_path) &lt; 1) or (MAX_PATH_LENGTH &lt; len(file_path)):\n        raise ValueError(\n            f\"`file_path` argument length {len(file_path)} is out of range, \"\n            f\"must be between 1 and {MAX_PATH_LENGTH} characters!\"\n        )\n\n    if isinstance(warn_mode, str):\n        warn_mode = WarnEnum(warn_mode.strip().upper())\n\n    if os.path.isfile(file_path):\n        try:\n            _message = f\"Removing '{file_path}' file...\"\n            if warn_mode == WarnEnum.ALWAYS:\n                logger.info(_message)\n            elif warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n            os.remove(file_path)\n        except OSError as err:\n            if (err.errno == errno.ENOENT) and (warn_mode == WarnEnum.DEBUG):\n                logger.debug(f\"'{file_path}' file doesn't exist!\")\n            else:\n                logger.error(f\"Failed to remove '{file_path}' file!\")\n                raise\n\n        _message = f\"Successfully removed '{file_path}' file.\"\n        if warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n    elif warn_mode == WarnEnum.ERROR:\n        raise OSError(errno.ENOENT, f\"'{file_path}' file doesn't exist!\")\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/io/#src.potato_util.io.remove_files","title":"<code>remove_files(file_paths, warn_mode=WarnEnum.DEBUG)</code>","text":"<p>Remove files if <code>file_paths</code> exist.</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>(list[str], required)</code> <p>Remove file paths as list.</p> required <code>warn_mode</code> <code>WarnEnum | str</code> <p>Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.                                     Defaults to 'DEBUG'.</p> <code>DEBUG</code> Source code in <code>src/potato_util/io/_sync.py</code> <pre><code>@validate_call\ndef remove_files(\n    file_paths: list[str], warn_mode: WarnEnum | str = WarnEnum.DEBUG\n) -&gt; None:\n    \"\"\"Remove files if `file_paths` exist.\n\n    Args:\n        file_paths (list[str]     , required): Remove file paths as list.\n        warn_mode  (WarnEnum | str, optional): Warning message mode, for example: 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'.\n                                                Defaults to 'DEBUG'.\n    \"\"\"\n\n    for _file_path in file_paths:\n        remove_file(file_path=_file_path, warn_mode=warn_mode)\n\n    return\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/sanitizer/","title":"Sanitizer Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/sanitizer/#src.potato_util.sanitizer.escape_html","title":"<code>escape_html(val)</code>","text":"<p>Escape HTML characters.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to escape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Escaped string.</p> Source code in <code>src/potato_util/sanitizer.py</code> <pre><code>@validate_call\ndef escape_html(val: str) -&gt; str:\n    \"\"\"Escape HTML characters.\n\n    Args:\n        val (str, required): String to escape.\n\n    Returns:\n        str: Escaped string.\n    \"\"\"\n\n    val = val.strip()\n    _escaped = html.escape(val)\n    return _escaped\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/sanitizer/#src.potato_util.sanitizer.escape_url","title":"<code>escape_url(val)</code>","text":"<p>Escape URL characters.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(AnyHttpUrl, required)</code> <p>String to escape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Escaped string.</p> Source code in <code>src/potato_util/sanitizer.py</code> <pre><code>@validate_call\ndef escape_url(val: AnyHttpUrl | str) -&gt; str:\n    \"\"\"Escape URL characters.\n\n    Args:\n        val (AnyHttpUrl, required): String to escape.\n\n    Returns:\n        str: Escaped string.\n    \"\"\"\n\n    if isinstance(val, str):\n        val = AnyHttpUrl(val)\n\n    _escaped = quote(str(val))\n    return _escaped\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/sanitizer/#src.potato_util.sanitizer.sanitize_special_chars","title":"<code>sanitize_special_chars(val, mode='LOW')</code>","text":"<p>Sanitize special characters. Available modes:     - \"BASE\" or \"HTML\": Basic HTML special characters.     - \"LOW\": Low-risk special characters.     - \"MEDIUM\": Medium-risk special characters.     - \"HIGH\", \"SCRIPT\", or \"SQL\": High-risk special characters.     - \"STRICT\": Strict mode, removes most special characters.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to sanitize.</p> required <code>mode</code> <code>str</code> <p>Sanitization mode. Defaults to \"LOW\".</p> <code>'LOW'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>mode</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Sanitized string.</p> Source code in <code>src/potato_util/sanitizer.py</code> <pre><code>@validate_call\ndef sanitize_special_chars(val: str, mode: str = \"LOW\") -&gt; str:\n    \"\"\"Sanitize special characters.\n    Available modes:\n        - \"BASE\" or \"HTML\": Basic HTML special characters.\n        - \"LOW\": Low-risk special characters.\n        - \"MEDIUM\": Medium-risk special characters.\n        - \"HIGH\", \"SCRIPT\", or \"SQL\": High-risk special characters.\n        - \"STRICT\": Strict mode, removes most special characters.\n\n    Args:\n        val  (str, required): String to sanitize.\n        mode (str, optional): Sanitization mode. Defaults to \"LOW\".\n\n    Raises:\n        ValueError: If `mode` argument value is invalid.\n\n    Returns:\n        str: Sanitized string.\n    \"\"\"\n\n    _pattern = r\"\"\n    mode = mode.upper().strip()\n    if (mode == \"BASE\") or (mode == \"HTML\"):\n        _pattern = SPECIAL_CHARS_BASE_REGEX\n    elif mode == \"LOW\":\n        _pattern = SPECIAL_CHARS_LOW_REGEX\n    elif mode == \"MEDIUM\":\n        _pattern = SPECIAL_CHARS_MEDIUM_REGEX\n    elif (mode == \"HIGH\") or (mode == \"SCRIPT\") or (mode == \"SQL\"):\n        _pattern = SPECIAL_CHARS_HIGH_REGEX\n    elif mode == \"STRICT\":\n        _pattern = SPECIAL_CHARS_STRICT_REGEX\n    else:\n        raise ValueError(f\"`mode` argument value '{mode}' is invalid!\")\n\n    _sanitized = re.sub(pattern=_pattern, repl=\"\", string=val)\n    return _sanitized\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/secure/","title":"Secure Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/secure/#src.potato_util.secure.hash_str","title":"<code>hash_str(val, algorithm=HashAlgoEnum.sha256)</code>","text":"<p>Hash a string using a specified hash algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str | bytes, required)</code> <p>The value to be hashed.</p> required <code>algorithm</code> <code>HashAlgoEnum | str</code> <p>The hash algorithm to use. Defaults to <code>HashAlgoEnum.sha256</code>.</p> <code>sha256</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hexadecimal representation of the digest.</p> Source code in <code>src/potato_util/secure.py</code> <pre><code>@validate_call\ndef hash_str(\n    val: str | bytes, algorithm: HashAlgoEnum | str = HashAlgoEnum.sha256\n) -&gt; str:\n    \"\"\"Hash a string using a specified hash algorithm.\n\n    Args:\n        val       (str | bytes       , required): The value to be hashed.\n        algorithm (HashAlgoEnum | str, optional): The hash algorithm to use. Defaults to `HashAlgoEnum.sha256`.\n\n    Returns:\n        str: The hexadecimal representation of the digest.\n    \"\"\"\n\n    if isinstance(val, str):\n        val = val.encode(\"utf-8\")\n\n    if isinstance(algorithm, str):\n        algorithm = HashAlgoEnum(algorithm.strip().lower())\n\n    _hash = hashlib.new(algorithm.value)\n    _hash.update(val)\n\n    _hash_val = _hash.hexdigest()\n    return _hash_val\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/","title":"Validator Utilities","text":"","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.has_special_chars","title":"<code>has_special_chars(val, mode='LOW')</code>","text":"<p>Check if the string has special characters. Available modes:     - \"BASE\" or \"HTML\": Basic HTML special characters.     - \"LOW\": Low-risk special characters.     - \"MEDIUM\": Medium-risk special characters.     - \"HIGH\", \"SCRIPT\", or \"SQL\": High-risk special characters.     - \"STRICT\": Strict mode, checks for most special characters.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to check.</p> required <code>mode</code> <code>str</code> <p>Check mode. Defaults to \"LOW\".</p> <code>'LOW'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>mode</code> argument value is invalid.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string has special characters, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef has_special_chars(val: str, mode: str = \"LOW\") -&gt; bool:\n    \"\"\"Check if the string has special characters.\n    Available modes:\n        - \"BASE\" or \"HTML\": Basic HTML special characters.\n        - \"LOW\": Low-risk special characters.\n        - \"MEDIUM\": Medium-risk special characters.\n        - \"HIGH\", \"SCRIPT\", or \"SQL\": High-risk special characters.\n        - \"STRICT\": Strict mode, checks for most special characters.\n\n    Args:\n        val  (str, required): String to check.\n        mode (str, optional): Check mode. Defaults to \"LOW\".\n\n    Raises:\n        ValueError: If `mode` argument value is invalid.\n\n    Returns:\n        bool: True if the string has special characters, False otherwise.\n    \"\"\"\n\n    _has_special_chars = False\n\n    _pattern = r\"\"\n    mode = mode.upper().strip()\n    if (mode == \"BASE\") or (mode == \"HTML\"):\n        _pattern = SPECIAL_CHARS_BASE_REGEX\n    elif mode == \"LOW\":\n        _pattern = SPECIAL_CHARS_LOW_REGEX\n    elif mode == \"MEDIUM\":\n        _pattern = SPECIAL_CHARS_MEDIUM_REGEX\n    elif (mode == \"HIGH\") or (mode == \"SCRIPT\") or (mode == \"SQL\"):\n        _pattern = SPECIAL_CHARS_HIGH_REGEX\n    elif mode == \"STRICT\":\n        _pattern = SPECIAL_CHARS_STRICT_REGEX\n    else:\n        raise ValueError(f\"`mode` argument value '{mode}' is invalid!\")\n\n    _has_special_chars = bool(re.search(pattern=_pattern, string=val))\n    return _has_special_chars\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.is_blacklisted","title":"<code>is_blacklisted(val, blacklist)</code>","text":"<p>Check if the string is blacklisted.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to check.</p> required <code>blacklist</code> <code>(List[str], required)</code> <p>List of blacklisted strings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is blacklisted, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef is_blacklisted(val: str, blacklist: list[str]) -&gt; bool:\n    \"\"\"Check if the string is blacklisted.\n\n    Args:\n        val       (str      , required): String to check.\n        blacklist (List[str], required): List of blacklisted strings.\n\n    Returns:\n        bool: True if the string is blacklisted, False otherwise.\n    \"\"\"\n\n    for _blacklisted in blacklist:\n        if _blacklisted in val:\n            return True\n\n    return False\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.is_falsy","title":"<code>is_falsy(val)</code>","text":"<p>Check if the value is falsy.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str | bool | int | float | None, required)</code> <p>Value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is falsy, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef is_falsy(val: str | bool | int | float | None) -&gt; bool:\n    \"\"\"Check if the value is falsy.\n\n    Args:\n        val (str | bool | int | float | None, required): Value to check.\n\n    Returns:\n        bool: True if the value is falsy, False otherwise.\n    \"\"\"\n\n    return not is_truthy(val)\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.is_request_id","title":"<code>is_request_id(val)</code>","text":"<p>Check if the string is valid request ID.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is valid request ID, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef is_request_id(val: str) -&gt; bool:\n    \"\"\"Check if the string is valid request ID.\n\n    Args:\n        val (str, required): String to check.\n\n    Returns:\n        bool: True if the string is valid request ID, False otherwise.\n    \"\"\"\n\n    _is_valid = bool(re.match(pattern=REQUEST_ID_REGEX, string=val))\n    return _is_valid\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.is_truthy","title":"<code>is_truthy(val)</code>","text":"<p>Check if the value is truthy.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str | bool | int | float | None, required)</code> <p>Value to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>val</code> argument type is string and value is invalid.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is truthy, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef is_truthy(val: str | bool | int | float | None) -&gt; bool:\n    \"\"\"Check if the value is truthy.\n\n    Args:\n        val (str | bool | int | float | None, required): Value to check.\n\n    Raises:\n        ValueError: If `val` argument type is string and value is invalid.\n\n    Returns:\n        bool: True if the value is truthy, False otherwise.\n    \"\"\"\n\n    if isinstance(val, str):\n        val = val.strip().lower()\n\n        if val in [\"0\", \"false\", \"f\", \"no\", \"n\", \"off\"]:\n            return False\n        elif val in [\"1\", \"true\", \"t\", \"yes\", \"y\", \"on\"]:\n            return True\n        else:\n            raise ValueError(f\"`val` argument value is invalid: '{val}'!\")\n\n    return bool(val)\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"api-docs/validator/#src.potato_util.validator.is_valid","title":"<code>is_valid(val, pattern)</code>","text":"<p>Check if the string is valid with given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>(str, required)</code> <p>String to check.</p> required <code>pattern</code> <code>(Pattern | str, required)</code> <p>Pattern regex to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is valid with given pattern, False otherwise.</p> Source code in <code>src/potato_util/validator.py</code> <pre><code>@validate_call\ndef is_valid(val: str, pattern: Pattern | str) -&gt; bool:\n    \"\"\"Check if the string is valid with given pattern.\n\n    Args:\n        val     (str          , required): String to check.\n        pattern (Pattern | str, required): Pattern regex to check.\n\n    Returns:\n        bool: True if the string is valid with given pattern, False otherwise.\n    \"\"\"\n\n    _is_valid = bool(re.match(pattern=pattern, string=val))\n    return _is_valid\n</code></pre>","tags":["api-docs","api-reference"]},{"location":"dev/build/","title":"\ud83c\udfd7\ufe0f Build Python Package","text":"<p>To build the python package, run the following command:</p> <pre><code># Install python build dependencies:\npip install -r ./requirements/requirements.build.txt\n\n# Build python package:\npython -m build\n# Or use the build script:\n./scripts/build.sh\n</code></pre>","tags":["dev","development"]},{"location":"dev/build/#build","title":"Build","text":"<pre><code># Install python build:\npip install -U build\n\n# Build help:\npython -m build --help\n</code></pre>","tags":["dev","development"]},{"location":"dev/build/#references","title":"References","text":"<ul> <li>Python Packaging User Guide</li> <li>Packaging Python Projects</li> <li>Writing your <code>pyproject.toml</code></li> <li>Setuptools Documentation</li> <li>Blogs:<ul> <li>Python Packaging Best Practices</li> <li>Generic Folder Structure for your Machine Learning Projects</li> <li>How to Upload your Python Package to PyPI</li> </ul> </li> </ul>","tags":["dev","development"]},{"location":"dev/contributing/","title":"\ud83e\udd1d Contributing","text":"<p>This project is encourages contributions!</p>","tags":["dev","development"]},{"location":"dev/diagrams/","title":"\ud83d\uddbc\ufe0f Diagrams","text":"<p>This page contains diagrams that illustrate the architecture of the module.</p>","tags":["dev","development"]},{"location":"dev/diagrams/#class","title":"Class","text":"","tags":["dev","development"]},{"location":"dev/diagrams/#package","title":"Package","text":"","tags":["dev","development"]},{"location":"dev/docs/","title":"\ud83d\udcdd Docs","text":"<p>To build the documentation, run the following command:</p> <pre><code># Install python documentation dependencies:\npip install -r ./requirements/requirements.docs.txt\n\n# Serve documentation locally (for development):\nmkdocs serve -a 0.0.0.0:8000 --livereload\n# Or use the docs script:\n./scripts/docs.sh\n\n# Or build documentation:\nmkdocs build\n# Or use the docs script:\n./scripts/docs.sh -b\n</code></pre>","tags":["dev","development"]},{"location":"dev/docs/#diagrams","title":"Diagrams","text":"<p>Prerequisites:</p> <ul> <li>Install Graphviz</li> </ul> <p>To generate diagrams, run the following command:</p> <pre><code># Install python documentation dependencies:\npip install -r ./requirements/requirements.docs.txt\n\n# Generate diagrams:\n./scripts/diagrams.sh\n</code></pre>","tags":["dev","development"]},{"location":"dev/docs/#mkdocs-material","title":"MkDocs Material","text":"","tags":["dev","development"]},{"location":"dev/docs/#installation","title":"Installation","text":"<pre><code># Install mkdocs-material and mkdocstrings:\npip install -U mkdocs-material mkdocstrings[python]\n</code></pre>","tags":["dev","development"]},{"location":"dev/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>","tags":["dev","development"]},{"location":"dev/docs/#docs-layout","title":"Docs layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>","tags":["dev","development"]},{"location":"dev/docs/#references","title":"References","text":"<ul> <li>MkDocs Documentation</li> <li>MkDocs Material Documentation</li> <li>mkdocstrings Documentation</li> </ul>","tags":["dev","development"]},{"location":"dev/file-structure/","title":"\ud83d\udcc2 File Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 .github/                # GitHub specific files\n|   \u251c\u2500\u2500 workflows/              # GitHub actions as workflows\n|   \u2514\u2500\u2500 release.yml             # Categories and labels for release notes\n\u251c\u2500\u2500 .vscode/                # VSCode specific files\n|   \u251c\u2500\u2500 extensions.json         # Recommended extensions for the workspace\n|   \u2514\u2500\u2500 settings.json           # Common VSCode settings for the workspace (e.g. formatting, linting, etc...)\n\u251c\u2500\u2500 build/                  # Build files and directories (SHOULD NOT BE COMMITTED TO REPOSITORY)\n\u251c\u2500\u2500 dist/                   # Built distributions of this project (SHOULD NOT BE COMMITTED TO REPOSITORY)\n\u251c\u2500\u2500 docs/                   # Documentation of this project\n|   \u251c\u2500\u2500 assets/                 # Any assets (images, audios, videos, js, css, html, etc...) used for the documentation\n|   \u251c\u2500\u2500 diagrams/               # Diagrams related to this project\n|   \u251c\u2500\u2500 blog/                   # Blog posts related to this project\n|   \u2514\u2500\u2500 .../                    # MkDocs pages - markdown files\n\u251c\u2500\u2500 examples/               # Example source codes of this project\n\u251c\u2500\u2500 requirements/           # Python dependency requirements for different environments\n\u251c\u2500\u2500 scripts/                # Helpful scripts to automate tasks or assist in the development process\n\u251c\u2500\u2500 site/                   # Built static site of the documentation (SHOULD NOT BE COMMITTED TO REPOSITORY)\n\u251c\u2500\u2500 src/                    # Source codes of this project\n|   \u251c\u2500\u2500 modules/                # External modules for this project\n|   |   \u251c\u2500\u2500 module_1/\n|   |   \u251c\u2500\u2500 module_2/\n|   |   \u2514\u2500\u2500 .../\n|   \u2514\u2500\u2500 potato_util/            # Main CODEBASE of this project as a python module\n|       \u251c\u2500\u2500 __init__.py             # Initialize the module to be used as a package\n|       \u251c\u2500\u2500 __version__.py          # Version of the module (should be updated and used with each release)\n|       \u2514\u2500\u2500 ...                     # Other main python files of this module\n\u251c\u2500\u2500 templates/              # Template files (if any, e.g. config files, etc...) used in this project\n\u251c\u2500\u2500 tests/                  # Tests for this project\n|   \u251c\u2500\u2500 __init__.py             # Initialize the test module\n|   \u251c\u2500\u2500 conftest.py             # Presets for pytest (e.g. fixtures, plugins, pre/post test hooks, etc...)\n|   \u251c\u2500\u2500 test_1.py               # Test case files\n|   \u251c\u2500\u2500 test_2.py\n|   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 __init__.py             # Initialize the whole project as a python module to import from other modules\n\u251c\u2500\u2500 .editorconfig           # Editor configuration for consistent coding styles for different editors\n\u251c\u2500\u2500 .env                    # Environment variables file (SHOULD NOT BE COMMITTED TO REPOSITORY)\n\u251c\u2500\u2500 .env.example            # Example environment variables file\n\u251c\u2500\u2500 .gitignore              # Files and directories to be ignored by git (e.g. data, models, results, etc...)\n\u251c\u2500\u2500 .markdownlint.json      # Markdown linting rules\n\u251c\u2500\u2500 .pre-commit-config.yaml # Pre-commit configuration file\n\u251c\u2500\u2500 CHANGELOG.md            # List of changes for each version of the project\n\u251c\u2500\u2500 environment.yml         # Conda environment file\n\u251c\u2500\u2500 LICENSE.txt             # License file for this project\n\u251c\u2500\u2500 Makefile                # Makefile for common commands and automation\n\u251c\u2500\u2500 MANIFEST.in             # Manifest file for setuptools (to include/exclude files in the source distribution)\n\u251c\u2500\u2500 mkdocs.yml              # MkDocs configuration file\n\u251c\u2500\u2500 pyproject.toml          # PEP 518 configuration file for python packaging\n\u251c\u2500\u2500 pytest.ini              # Pytest configuration file\n\u251c\u2500\u2500 README.md               # Main README file for this project\n\u251c\u2500\u2500 requirements.txt        # Main python dependency requirements for this project\n\u251c\u2500\u2500 setup.cfg               # Configuration for setuptools\n\u2514\u2500\u2500 setup.py                # Setup script for setuptools (for backward compatibility)\n</code></pre>","tags":["dev","development"]},{"location":"dev/related-projects/","title":"\ud83d\uddc2 Related Projects","text":"<p>This section lists related projects or sub-module projects that are part of this project.</p>","tags":["dev","development"]},{"location":"dev/roadmap/","title":"\ud83d\udee4 Roadmap","text":"<p>This project is still in its early stages of development.</p> <p>The following is a list of features that are planned for future releases:</p>","tags":["dev","development"]},{"location":"dev/sitemap/","title":"\ud83d\uddfa\ufe0f Sitemap","text":"<ul> <li>Home</li> <li>Getting Started<ul> <li>Prerequisites</li> <li>Installation</li> <li>Configuration</li> <li>Examples</li> </ul> </li> <li>API Documentation</li> <li>Development<ul> <li>Test</li> <li>Build</li> <li>Docs</li> <li>Scripts<ul> <li>clean.sh</li> <li>get-version.sh</li> <li>test.sh</li> <li>bump-version.sh</li> <li>build.sh</li> <li>release.sh</li> <li>changelog.sh</li> <li>diagrams.sh</li> <li>docs.sh</li> </ul> </li> <li>CI/CD<ul> <li>1.bump-version.yml</li> <li>2.build-publish.yml</li> <li>3.update-changelog.yml</li> <li>publish-docs.yml</li> </ul> </li> <li>Diagrams</li> <li>File Structure</li> <li>Sitemap</li> <li>Related Projects</li> <li>Contributing</li> <li>Roadmap</li> </ul> </li> <li>Release Notes</li> <li>About<ul> <li>FAQ</li> <li>Authors</li> <li>Contact</li> <li>License</li> </ul> </li> </ul>","tags":["dev","development"]},{"location":"dev/test/","title":"\ud83e\uddea Test","text":"<p>To run tests, run the following command:</p> <pre><code># Install python test dependencies:\npip install .[test]\n\n# Run tests:\npython -m pytest -sv -o log_cli=true\n# Or use the test script:\n./scripts/test.sh -l -v -c\n</code></pre>","tags":["dev","development"]},{"location":"dev/test/#pytest","title":"Pytest","text":"<pre><code># Install pytest:\npip install -U pytest pytest-cov pytest-xdist pytest-benchmark\n\n# Run tests:\npython -m pytest\n\n# Pytest help:\npython -m pytest --help\n</code></pre>","tags":["dev","development"]},{"location":"dev/test/#references","title":"References","text":"<ul> <li>Pytest Documentation</li> <li>Pytest Getting Started</li> <li>Pytest Fixtures</li> <li>Blogs:<ul> <li>https://docs.pytest.org/en/latest/goodpractices.html</li> <li>https://emimartin.me/pytest_best_practices</li> <li>https://esaezgil.com/post/unittesting_pitfalls</li> <li>https://pytest-with-eric.com/mocking/pytest-common-mocking-problems</li> </ul> </li> </ul>","tags":["dev","development"]},{"location":"dev/cicd/","title":"\ud83d\udc77 CI/CD","text":"<p>This section provides information on how to setup and configure CI/CD pipelines for this project.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/#github-actions","title":"GitHub Actions","text":"<ul> <li><code>1.bump-version.yml</code>: Bumps the project version.</li> <li><code>2.build-publish.yml</code>: Builds, publishes and creates release of python package.</li> <li><code>3.update-changelog.yml</code>: Updates the changelog.</li> <li><code>publish-docs.yml</code>: Publishes the documentation.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/#references","title":"References","text":"<ul> <li>GitHub Actions Documentation</li> <li>GitHub Actions Marketplace</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/","title":"\u2b06\ufe0f Bump Version","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#overview","title":"Overview","text":"<p>This GitHub Action automates the process of bumping the project version. It allows users to choose whether to increment the version as a patch, minor, or major release. This workflow consists of two main jobs:</p> <ol> <li>Test: Runs tests before bumping the version.</li> <li>Bump Version: Increases the project version and commits the changes.</li> </ol>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#how-it-works","title":"How It Works","text":"<p>The workflow is triggered manually via GitHub's <code>workflow_dispatch</code> event. Users must select the type of version bump before execution.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#workflow-configuration","title":"Workflow Configuration","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#trigger","title":"Trigger","text":"<p>The action is triggered manually by dispatching a workflow with an input parameter <code>bump_type</code>, which can have one of the following values:</p> <ul> <li><code>patch</code></li> <li><code>minor</code></li> <li><code>major</code></li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#jobs","title":"Jobs","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#1-test-11-test","title":"1. Test (1.1. Test)","text":"<p>This job ensures the code is tested before making version changes.</p> <ul> <li>Runs on: <code>ubuntu-24.04</code></li> <li>Permissions: <code>contents: read</code></li> <li>Steps:<ol> <li>Checkout the repository</li> <li>Install dependencies (from <code>requirements/requirements.test.txt</code>)</li> <li>Run tests using <code>pytest</code> via <code>./scripts/test.sh -l</code></li> </ol> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#2-bump-version-12-bump-version","title":"2. Bump Version (1.2. Bump Version)","text":"<p>This job updates the project version after tests pass.</p> <ul> <li>Runs on: <code>ubuntu-24.04</code></li> <li>Permissions: <code>contents: write</code></li> <li>Steps:<ol> <li>Checkout the repository (with full history)</li> <li>Bump the version using <code>./scripts/bump-version.sh</code></li> <li>Commits and pushes changes using GitHub Actions bot</li> </ol> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#usage","title":"Usage","text":"<p>To manually trigger this workflow:</p> <ol> <li>Navigate to the repository on GitHub.</li> <li>Go to the Actions tab.</li> <li>Select \"1. Bump Version\" from the list.</li> <li>Click \"Run workflow\".</li> <li>Choose a version bump type (<code>patch</code>, <code>minor</code>, or <code>major</code>).</li> <li>Click \"Run workflow\" to start the process.</li> </ol>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#environment-variables","title":"Environment Variables","text":"<p>The workflow uses the following environment variables:</p> <ul> <li><code>GITHUB_TOKEN</code>: GitHub-provided authentication token for making commits.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#scripts-used","title":"Scripts Used","text":"<ul> <li><code>test.sh</code>: Runs the test suite.</li> <li><code>bump-version.sh</code>: Handles version incrementing.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#notes","title":"Notes","text":"<ul> <li>Ensure that <code>bump-version.sh</code> supports <code>-b</code>, <code>-c</code>, and <code>-p</code> options.</li> <li>The workflow ensures that version bumping occurs only if tests pass.</li> <li>The changes are committed and pushed automatically to the repository.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/1.bump-version/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If the workflow fails in the <code>test</code> step, check test logs for errors.</li> <li>If version bumping fails, ensure <code>bump-version.sh</code> is executable and correctly configured.</li> <li>If permissions errors occur, verify that GitHub Actions has the required <code>contents: write</code> permission.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/","title":"\ud83d\ude80 Build and Publish","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#overview","title":"Overview","text":"<p>This GitHub Action automates the process of building and publishing the project. It triggers automatically after a version bump or when a tag (<code>v*.*.*</code>) is pushed. The workflow builds the package and optionally publishes it to a package registry.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#how-it-works","title":"How It Works","text":"<p>The workflow runs in the following scenarios:</p> <ul> <li>After Bump Version workflow completes.</li> <li>When a new tag (<code>v*.*.*</code>) is pushed to the repository.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#workflow-configuration","title":"Workflow Configuration","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#trigger","title":"Trigger","text":"<ul> <li>Triggered by:<ul> <li>Completion of <code>1. Bump Version</code> workflow.</li> <li>Push event on tags matching <code>v*.*.*</code>.</li> </ul> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#jobs","title":"Jobs","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#1-build-and-publish","title":"1. Build and Publish","text":"<p>This job builds the package and creates a release.</p> <ul> <li>Runs on: <code>ubuntu-24.04</code></li> <li>Permissions: <code>contents: write</code></li> <li>Steps:<ol> <li>Checkout the repository</li> <li>Install dependencies (from <code>requirements/requirements.build.txt</code>)</li> <li>Build the package using <code>./scripts/build.sh -c</code></li> <li>Create a release using GitHub CLI (<code>gh release create</code>)</li> </ol> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#usage","title":"Usage","text":"<p>This workflow runs automatically when a new version is tagged. However, you can manually trigger a tag and push it:</p> <ol> <li>Bump the version using the <code>1. Bump Version</code> workflow.</li> <li> <p>Create a tag manually and push it:</p> <pre><code>git tag v1.2.3\ngit push origin v1.2.3\n</code></pre> </li> <li> <p>The workflow will build and publish the package.</p> </li> </ol>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>GITHUB_TOKEN</code>: Used for creating GitHub releases.</li> <li><code>PYPI_API_TOKEN</code> (if enabled): Used for publishing packages to PyPI.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#scripts-used","title":"Scripts Used","text":"<ul> <li><code>build.sh</code>: Builds the package.</li> <li><code>get-version.sh</code>: Retrieves the current version.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#notes","title":"Notes","text":"<ul> <li>This workflow supports both GitHub Releases and optional package publishing.</li> <li>Ensure <code>build.sh</code> is executable and correctly configured.</li> <li>If the workflow fails, check logs for errors related to dependencies or authentication.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/2.build-publish/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If the build step fails, ensure dependencies are correctly installed.</li> <li>If release creation fails, verify that <code>GITHUB_TOKEN</code> has the necessary permissions.</li> <li>If publishing to PyPI fails, check that the API token is correctly set up in repository secrets.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/","title":"\ud83d\udca5 Update Changelog","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#overview","title":"Overview","text":"<p>This GitHub Action automates the process of updating the changelog after a new release is built and published. It ensures that the changelog remains up to date with the latest changes in the repository.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#how-it-works","title":"How It Works","text":"<p>The workflow is triggered automatically after the Build and Publish workflow is successfully completed.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#workflow-configuration","title":"Workflow Configuration","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#trigger","title":"Trigger","text":"<ul> <li>Triggered by:<ul> <li>Completion of <code>2. Build and Publish</code> workflow.</li> </ul> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#jobs","title":"Jobs","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#1-update-changelog","title":"1. Update Changelog","text":"<p>This job updates the changelog after a new release.</p> <ul> <li>Runs on: <code>ubuntu-24.04</code></li> <li>Permissions: <code>contents: write</code></li> <li>Steps:<ol> <li>Checkout the repository (with full history for changelog updates)</li> <li>Update the changelog using <code>./scripts/changelog.sh -c -p</code></li> <li>Commits and pushes changes using GitHub Actions bot</li> </ol> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#usage","title":"Usage","text":"<p>This workflow runs automatically when a new release is created. However, you can manually update the changelog by running the script locally:</p> <pre><code>./scripts/changelog.sh -c -p\n</code></pre>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>GITHUB_TOKEN</code>: Used for authentication and committing changes.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#scripts-used","title":"Scripts Used","text":"<ul> <li><code>changelog.sh</code>: Updates the changelog file.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#notes","title":"Notes","text":"<ul> <li>Ensure that <code>changelog.sh</code> is executable and correctly configured.</li> <li>The workflow ensures that changelog updates occur only after a successful release build.</li> <li>The changes are committed and pushed automatically to the repository.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/3.update-changelog/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If the workflow fails, ensure that <code>changelog.sh</code> is present and executable.</li> <li>If there are permissions errors, verify that GitHub Actions has the required <code>contents: write</code> permission.</li> <li>Check logs for any issues related to Git authentication or script execution.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/","title":"\ud83d\udcdd Publish Docs","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#overview","title":"Overview","text":"<p>This GitHub Action automates the process of publishing documentation using MkDocs whenever changes are pushed to the <code>main</code> branch. It ensures that the latest documentation is deployed automatically.</p>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#how-it-works","title":"How It Works","text":"<p>The workflow is triggered when changes are made to:</p> <ul> <li>The <code>docs/</code> directory.</li> <li>The <code>mkdocs.yml</code> configuration file.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#workflow-configuration","title":"Workflow Configuration","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#trigger","title":"Trigger","text":"<ul> <li>Triggered by:<ul> <li>A push event to the <code>main</code> branch that modifies documentation files.</li> </ul> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#jobs","title":"Jobs","text":"","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#1-publish-docs","title":"1. Publish Docs","text":"<p>This job builds and deploys the documentation using MkDocs.</p> <ul> <li>Runs on: <code>ubuntu-24.04</code></li> <li>Permissions: <code>contents: write</code></li> <li>Steps:<ol> <li>Checkout the repository (with full history for proper deployment tracking).</li> <li>Install dependencies from <code>requirements/requirements.docs.txt</code></li> <li>Publish the documentation using <code>mkdocs gh-deploy --force</code></li> </ol> </li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#usage","title":"Usage","text":"<p>This workflow runs automatically when changes are pushed to the <code>main</code> branch. However, you can manually deploy the documentation by running the following command locally:</p> <pre><code>mkdocs gh-deploy --force\n</code></pre>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>GITHUB_TOKEN</code>: Used for authentication and deploying the documentation.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#scripts-used","title":"Scripts Used","text":"<ul> <li><code>mkdocs.yml</code>: Configuration file for MkDocs.</li> <li>Files in <code>docs/</code>: Documentation content.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#notes","title":"Notes","text":"<ul> <li>Ensure that <code>mkdocs</code> and required dependencies are correctly installed in <code>requirements.docs.txt</code>.</li> <li>The workflow ensures that documentation updates occur only when relevant files are modified.</li> <li>The changes are committed and published automatically to GitHub Pages.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/cicd/publish-docs/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If the workflow fails, ensure that <code>mkdocs</code> is properly installed and configured.</li> <li>If deployment issues occur, verify that GitHub Actions has the required <code>contents: write</code> permission.</li> <li>Check logs for any issues related to Git authentication or MkDocs execution.</li> </ul>","tags":["dev","development","cicd"]},{"location":"dev/scripts/","title":"\ud83d\udd28 Scripts","text":"<p>This document provides an overview and usage instructions for the following scripts in this project:</p> <ul> <li><code>clean.sh</code></li> <li><code>get-version.sh</code></li> <li><code>test.sh</code></li> <li><code>bump-version.sh</code></li> <li><code>build.sh</code></li> <li><code>release.sh</code></li> <li><code>changelog.sh</code></li> <li><code>diagrams.sh</code></li> <li><code>docs.sh</code></li> </ul> <p>All the scripts are located in the <code>scripts</code> directory:</p> <pre><code>scripts/\n\u251c\u2500\u2500 build.sh\n\u251c\u2500\u2500 bump-version.sh\n\u251c\u2500\u2500 changelog.sh\n\u251c\u2500\u2500 clean.sh\n\u251c\u2500\u2500 diagrams.sh\n\u251c\u2500\u2500 docs.sh\n\u251c\u2500\u2500 get-version.sh\n\u251c\u2500\u2500 release.sh\n\u2514\u2500\u2500 test.sh\n</code></pre> <p>These scripts are designed to be used in a Linux or macOS environment. They may work in a Windows environment with the appropriate tools installed, but this is not guaranteed.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/build.sh/","title":"\ud83c\udfd7\ufe0f build.sh","text":"<p>This script is used to build a Python project and optionally run tests and publish the package. It also includes a cleaning operation to clear the build directories.</p> <p>This script has the following key features:</p> <ul> <li>Checking for required tools: It verifies if Python and the build package are installed on the system. If tests are not disabled, it also checks if pytest is installed. If uploading is enabled, it checks for the presence of Twine.</li> <li>Command-line argument parsing: It parses <code>-c</code> or <code>--disable-clean</code> to disable cleaning the build directories, <code>-t</code> or <code>--test</code> to enable running tests, <code>-u</code> or <code>--upload</code> to enable publishing the package, and <code>-p</code> or <code>--production</code> to switch the package repository from staging (default) to production.</li> <li>Clean operation: Cleans the build directories before and after building (if enabled). If <code>-c</code> or <code>--disable-clean</code> is passed, the script will not clean the build directories.</li> <li>Testing operation: Runs pytest tests if enabled by <code>-t</code> or <code>--test</code> flag.</li> <li>Build operation: Builds a Python package using the Python build package.</li> <li>Publishing operation: Publishes the built package to a PyPi repository using Twine if the <code>-u</code> or <code>--upload</code> flag is passed. Defaults to the TestPyPi (staging) repository, but can be switched to the production (PyPi) repository using the <code>-p</code> or <code>--production</code> flag.</li> </ul> <p>Usage:</p> <p>To execute the build script with the different flags, use the following commands:</p> <pre><code>./build.sh [-c|--disable-clean] [-t|--test] [-u|--upload] [-p|--production]\n</code></pre> <p>Examples:</p> <ul> <li>To build without cleaning: <code>./build.sh -c</code></li> <li>To build with running tests: <code>./build.sh -t</code></li> <li>To build and publish to the staging repository: <code>./build.sh -u</code></li> <li>To build and publish to the production repository: <code>./build.sh -u -p</code></li> </ul> <p>This script is particularly beneficial for developers, streamlining the build, testing, and publishing process. It provides a one-stop solution for all the build needs of a Python project, reducing chances of errors and ensuring consistency.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/bump-version.sh/","title":"\ud83c\udff7 bump-version.sh","text":"<p>This script is used to manage the versioning of the project. It allows you to increment the major, minor, or patch part of the version, as per Semantic Versioning rules.</p> <p>The script carries out the following operations:</p> <ul> <li>Loading environment variables: If a <code>.env</code> file is present in the root directory, the script loads the environment variables from this file.</li> <li>Sets variables: Sets the <code>VERSION_FILE_PATH</code> and other variables. The <code>VERSION_FILE_PATH</code> variable is either loaded from the environment or defaults to <code>src/potato_util/__version__.py</code>.</li> <li>Parses input arguments: It parses the <code>-b</code> or <code>--bump-type</code> argument for the type of version bump (<code>major</code>, <code>minor</code>, or <code>patch</code>) and <code>-p</code> or <code>--push-tag</code> to decide whether to push the tag to the Git repository or not.</li> <li>Checks and increments the version: It uses <code>get-version.sh</code> to extract the current version from the file specified by <code>VERSION_FILE_PATH</code>. Based on the bump type, it increments the appropriate part of the version and writes the new version back to the file.</li> <li>Commits and tags: If the <code>-p</code> or <code>--push-tag</code> flag was provided, it adds and commits the changes, pushes the changes, creates a new tag with the new version, and pushes the tag to the Git repository. It will prevent the operation if the tag already exists.</li> </ul> <p>Usage:</p> <p>To execute the bump version script, run the following command in the terminal:</p> <pre><code>./bump-version.sh -b=&lt;bump_type&gt; -p\n</code></pre> <p>Replace <code>&lt;bump_type&gt;</code> with either <code>major</code>, <code>minor</code>, or <code>patch</code> to indicate which part of the version to increment. The <code>-p</code> or <code>--push-tag</code> flag tells the script to commit the changes and push the tag to the Git repository.</p> <p>Examples:</p> <p>To bump the <code>minor</code> version and push the new tag, run:</p> <pre><code>./bump-version.sh -b=minor -p\n</code></pre> <p>This script streamlines the versioning process, reducing the chances of errors and ensuring consistency in versioning.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/bump-version.sh/#references","title":"References","text":"<ul> <li>https://semver.org</li> </ul>","tags":["dev","development","scripts"]},{"location":"dev/scripts/changelog.sh/","title":"\ud83d\udccc changelog.sh","text":"<p>This script automates updating both a <code>CHANGELOG.md</code> file and a <code>docs/release-notes.md</code> file using release information fetched from GitHub. It ensures consistent release documentation across the project and optionally commits and pushes changes to the Git repository.</p> <p>The script performs the following operations:</p> <ul> <li>Environment setup:  <ul> <li>Runs from the project root.  </li> <li>Loads environment variables from a <code>.env</code> file if present.  </li> </ul> </li> <li>Dependency checks:  <ul> <li>Ensures the GitHub CLI (<code>gh</code>) is installed and authenticated.  </li> <li>If <code>--commit</code> is specified, verifies that <code>git</code> is available.  </li> </ul> </li> <li>Variables setup:  <ul> <li><code>CHANGELOG_FILE_PATH</code> \u2192 Path to the changelog file (default: <code>./CHANGELOG.md</code>).  </li> <li><code>RELEASE_NOTES_FILE_PATH</code> \u2192 Path to the release notes file (default: <code>./docs/release-notes.md</code>).  </li> </ul> </li> <li>Input parsing:  <ul> <li><code>-c</code> or <code>--commit</code>: Commit changelog and release notes updates.  </li> <li><code>-p</code> or <code>--push</code>: Push updates to the remote repository (requires <code>-c</code>).  </li> </ul> </li> <li>Changelog update:  <ul> <li>Fetches the latest release tag and body from GitHub (<code>gh release view</code>).  </li> <li>Updates <code>CHANGELOG.md</code> with a new section for the latest release, including date and notes.  </li> </ul> </li> <li>Release notes update:  <ul> <li>Updates <code>docs/release-notes.md</code> with a formatted entry for the latest release.  </li> <li>Adds a YAML front matter block and header if the file does not already exist.  </li> </ul> </li> <li>Commit and push (optional):  <ul> <li>If <code>-c</code> is provided, stages and commits both updated files with a commit message.  </li> <li>If <code>-p</code> is also provided, pushes the commit to the remote repository.</li> </ul> </li> </ul>","tags":["dev","development","scripts"]},{"location":"dev/scripts/changelog.sh/#usage","title":"Usage","text":"<p>To execute <code>changelog.sh</code>, run:</p> <pre><code>./changelog.sh [-c|--commit] [-p|--push]\n</code></pre>","tags":["dev","development","scripts"]},{"location":"dev/scripts/clean.sh/","title":"\ud83e\uddf9 clean.sh","text":"<p>This script is designed to clean up the build environment by removing artifacts and other temporary or unwanted files and directories.</p> <p>The script performs the following operations:</p> <ul> <li>Delete system files: Finds and deletes all <code>.DS_Store</code> and <code>.Thumbs.db</code> files in the project directory and its subdirectories.</li> <li>Delete cache directories: Finds and deletes all <code>__pycache__</code> directories in the project directory and its subdirectories.</li> <li>Delete project-related directories: Removes directories created during the test and build process or by tools used in the project, such as <code>.benchmarks</code>, <code>.pytest_cache</code>, <code>build</code>, and <code>dist</code> directories.</li> <li>Delete <code>.coverage</code> file: Removes the <code>.coverage</code> file that's created when coverage information is collected for the project.</li> </ul> <p>Usage:</p> <p>To execute the clean script, simply run the following command in the terminal:</p> <pre><code>./clean.sh [-a|--all]\n</code></pre> <p>Examples:</p> <ul> <li>To clean just non-essential files: <code>./clean.sh</code></li> <li>To clean all files: <code>./clean.sh -a</code></li> </ul> <p>This will clean up the project directory, removing any unnecessary files and directories and ensuring a clean environment for a fresh build.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/diagrams.sh/","title":"\ud83d\uddbc\ufe0f diagrams.sh","text":"<p>This script generates UML diagrams for a specified Python module using <code>pyreverse</code>. It checks for dependencies, loads environment variables, sets directories, and processes command-line arguments for customization of module names, directories, and output locations.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/diagrams.sh/#overview","title":"Overview","text":"<p>The script performs the following operations:</p> <ul> <li> <p>Dependency Checks: Verifies the presence of required tools:</p> <ul> <li><code>graphviz</code> for <code>.dot</code> file handling.</li> <li><code>python</code> for running Python-based commands.</li> <li><code>pylint</code> (with <code>pyreverse</code>) for generating UML diagrams.</li> </ul> </li> <li> <p>Environment Variable Setup: Sets default values for module name, module directory, and output directory (<code>MODULE_NAME</code>, <code>MODULE_DIR</code>, <code>OUTPUT_DIR</code>). These can be customized via environment variables or command-line arguments.</p> </li> <li> <p>Argument Parsing: Parses optional arguments to allow customization:</p> <ul> <li><code>-m</code> or <code>--module-name</code> to specify the module name.</li> <li><code>-d</code> or <code>--module-dir</code> to specify the module directory.</li> <li><code>-o</code> or <code>--output-dir</code> to specify the output directory.</li> </ul> </li> <li> <p>Directory Creation: Creates subdirectories within the output directory for organizing different types of UML and flowchart outputs:</p> <ul> <li><code>classes</code> for class diagrams.</li> <li><code>packages</code> for package diagrams.</li> </ul> </li> <li> <p>Diagram Generation: Runs <code>pyreverse</code> to create UML diagrams in multiple formats (<code>html</code>, <code>pdf</code>, <code>png</code>, and <code>svg</code>) and organizes them into respective directories.</p> </li> <li> <p>Completion Message: Displays a message confirming successful generation of diagrams.</p> </li> </ul>","tags":["dev","development","scripts"]},{"location":"dev/scripts/diagrams.sh/#usage","title":"Usage","text":"<p>To run the script:</p> <pre><code>./diagrams.sh -m=&lt;module_name&gt; -d=&lt;module_dir&gt; -o=&lt;output_dir&gt;\n</code></pre>","tags":["dev","development","scripts"]},{"location":"dev/scripts/docs.sh/","title":"\ud83d\udcdd docs.sh","text":"<p>This script is used to manage the documentation for the project, providing options to either serve a local documentation server or build the documentation as static HTML files.</p> <p>The script performs the following operations:</p> <ul> <li>Serving documentation: If no flags are set, runs <code>mkdocs serve</code> to start a local documentation server for live preview.</li> <li>Building documentation: If the <code>-b</code> or <code>--build</code> flag is set, the script builds the documentation as static HTML files using <code>mkdocs build</code>, placing the output in the <code>site</code> directory.</li> <li>Publishing documentation: If the <code>-p</code> or <code>--publish</code> flag is set, the script can be extended to publish the documentation to GitHub Pages.</li> </ul> <p>Usage:</p> <p>To execute the documentation script, use the following command in the terminal:</p> <pre><code>./docs.sh [-b|--build] [-p|--publish]\n</code></pre> <p>Examples:</p> <ul> <li>To serve the documentation: <code>./docs.sh</code></li> <li>To build the documentation: <code>./docs.sh -b</code></li> <li>To publish the documentation: <code>./docs.sh -p</code></li> </ul>","tags":["dev","development","scripts"]},{"location":"dev/scripts/get-version.sh/","title":"\ud83d\udd0d get-version.sh","text":"<p>This script is used to retrieve the current version of the application from a specified version file.</p> <p>The script performs the following operations:</p> <ul> <li><code>VERSION_FILE_PATH</code> is either loaded from the environment or, if it's not present in the environment, it defaults to <code>src/potato_util/__version__.py</code>.</li> <li>It first checks if the <code>VERSION_FILE_PATH</code> variable is not empty and if the file exists. If these conditions are met, it retrieves the value of <code>__version__</code> from the file by using <code>grep</code>, <code>awk</code>, and <code>tr</code> commands. The <code>grep</code> command filters the line containing <code>__version__ =</code> , the <code>awk</code> command splits the line into two parts at <code>=</code>, and the <code>tr</code> command removes the quotes around the version. If these operations fail, it exits the script with status code <code>2</code>.</li> <li>If the <code>VERSION_FILE_PATH</code> variable is empty or the file does not exist, it sets the current version to <code>0.0.0</code>.</li> <li>Finally, it echoes the current version to the console.</li> </ul> <p>Usage:</p> <p>To execute the get version script, simply run the following command in the terminal:</p> <pre><code>./get-version.sh\n</code></pre> <p>This script can be used to conveniently fetch the version. It is used by the <code>bump-version.sh</code> script to retrieve the current version before incrementing it.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/release.sh/","title":"\ud83d\ude80 release.sh","text":"<p>This script automates the creation of GitHub Releases for the project. It optionally performs a build, retrieves the current version, and uploads artifacts from the <code>dist</code> directory to a new GitHub Release with autogenerated notes.</p> <p>The script performs the following operations:</p> <ul> <li>Environment setup:   Ensures it runs from the project root and sources environment variables from <code>.env</code> if available.</li> <li>Dependency checks:   Verifies that <code>git</code> and <code>gh</code> (GitHub CLI) are installed, and that the user is authenticated with <code>gh auth login</code>.</li> <li>Optional build:   If the <code>-b</code> or <code>--build</code> flag is set, runs <code>./scripts/build.sh -c</code> before release.</li> <li>Versioning:   Uses <code>./scripts/get-version.sh</code> to determine the release version.</li> <li>Release creation:   Runs <code>gh release create v&lt;version&gt; ./dist/* --generate-notes</code> to publish a new GitHub Release with attached artifacts.</li> </ul> <p>Usage:</p> <p>To execute the release script, use the following command in the terminal:</p> <pre><code>./release.sh [-b|--build]\n</code></pre> <p>Examples:</p> <ul> <li>To create a release using existing build artifacts: <code>./release.sh</code></li> <li>To build the project first, then create the release: <code>./release.sh -b</code></li> </ul> <p>Notes:</p> <ul> <li>A .env file is optional but will be loaded if present.</li> <li>The dist/ directory must contain the build artifacts before release.</li> <li>The release tag will be prefixed with v (e.g., v1.2.3).</li> </ul>","tags":["dev","development","scripts"]},{"location":"dev/scripts/test.sh/","title":"\ud83e\uddea test.sh","text":"<p>This script is used to run the pytest tests for the project.</p> <p>The script performs the following operations:</p> <ul> <li>Running pytest: Runs the pytest tests for the project.</li> <li>Logging: If the <code>-l</code> or <code>--log</code> option is provided, the script will log the output of the pytest tests to console.</li> <li>Coverage: If the <code>-c</code> or <code>--cov</code> option is provided, the script will run the pytest tests with coverage.</li> <li>Verbose: If the <code>-v</code> or <code>--verbose</code> option is provided, the script will run the pytest tests with verbose error outputs.</li> </ul> <p>Usage:</p> <p>To execute the test script, simply run the following command in the terminal:</p> <pre><code>./test.sh [-l|--log] [-c|--cov] [-v|--verbose]\n</code></pre> <p>Examples:</p> <ul> <li>To test: <code>./test.sh</code></li> <li>To test with logging: <code>./test.sh -l</code></li> <li>To test with coverage: <code>./test.sh -c</code></li> <li>To test with verbose: <code>./test.sh -v</code></li> <li>To test with logging, coverage and verbose: <code>./test.sh -l -c -v</code></li> </ul> <p>This script will run the pytest tests for the project. It can also be used to run the tests with logging, coverage, and verbose options.</p>","tags":["dev","development","scripts"]},{"location":"dev/scripts/test.sh/#references","title":"References","text":"<ul> <li>https://docs.pytest.org</li> </ul>","tags":["dev","development","scripts"]},{"location":"getting-started/configuration/","title":"Configuration","text":"","tags":["getting-started"]},{"location":"getting-started/configuration/#environment-variables","title":"\ud83c\udf0e Environment Variables","text":"<p><code>.env.example</code>:</p> <pre><code># ENV=LOCAL\n# DEBUG=false\n# TZ=UTC\n</code></pre>","tags":["getting-started"]},{"location":"getting-started/examples/","title":"\ud83d\udeb8 Examples","text":"","tags":["getting-started"]},{"location":"getting-started/examples/#simple","title":"Simple","text":"<p><code>examples/simple/main.py</code>:</p> <pre><code>#!/usr/bin/env python\n\n# Standard libraries\nimport os\nimport sys\nimport logging\n\n# Third-party libraries\nfrom pydantic import AnyHttpUrl\n\n# Internal modules\nimport potato_util\nimport potato_util.dt as dt_utils\nimport potato_util.generator as gen_utils\nimport potato_util.sanitizer as sanitizer_utils\nimport potato_util.secure as secure_utils\nimport potato_util.validator as validator_utils\nimport potato_util.http as http_utils\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef main() -&gt; None:\n    _log_level = logging.INFO\n    if str(os.getenv(\"DEBUG\", \"0\")).lower() in (\"1\", \"true\", \"t\", \"yes\", \"y\"):\n        _log_level = logging.DEBUG\n\n    logging.basicConfig(\n        stream=sys.stdout,\n        level=_log_level,\n        datefmt=\"%Y-%m-%d %H:%M:%S %z\",\n        format=\"[%(asctime)s | %(levelname)s | %(filename)s:%(lineno)d]: %(message)s\",\n    )\n\n    # Base utils:\n    logger.info(\"[BASE UTILITIES]\")\n    _dict1 = {\"a\": 1, \"b\": {\"c\": 2, \"d\": 3}, \"g\": [2, 3, 4]}\n    _dict2 = {\"b\": {\"c\": 20, \"e\": 30}, \"f\": 40, \"g\": [5, 6, 7]}\n    _merged_dict = potato_util.deep_merge(_dict1, _dict2)\n    logger.info(f\"Merged dict: {_merged_dict}\")\n\n    _camel_str = \"CamelCaseString\"\n    _snake_str = potato_util.camel_to_snake(_camel_str)\n    logger.info(f\"Converted '{_camel_str}' to '{_snake_str}'\")\n    logger.info(\"-\" * 80)\n\n    # Datetime utils:\n    logger.info(\"[DATETIME UTILITIES]\")\n    _now_local_dt = dt_utils.now_local_dt()\n    logger.info(f\"Current local datetime: {_now_local_dt}\")\n\n    _now_utc_dt = dt_utils.now_utc_dt()\n    logger.info(f\"Current UTC datetime: {_now_utc_dt}\")\n\n    _now_ny_dt = dt_utils.now_dt(tz=\"America/New_York\")\n    logger.info(f\"Current New York datetime: {_now_ny_dt}\")\n\n    _now_ts = dt_utils.now_ts()\n    logger.info(f\"Current UTC timestamp (seconds): {_now_ts}\")\n\n    _now_ts_ms = dt_utils.now_ts(unit=\"MILLISECONDS\")\n    logger.info(f\"Current UTC timestamp (ms): {_now_ts_ms}\")\n\n    _now_ts_micro = dt_utils.now_ts(unit=\"MICROSECONDS\")\n    logger.info(f\"Current UTC timestamp (microseconds): {_now_ts_micro}\")\n\n    _now_ts_ns = dt_utils.now_ts(unit=\"NANOSECONDS\")\n    logger.info(f\"Current UTC timestamp (nanoseconds): {_now_ts_ns}\")\n\n    _dt_ts = dt_utils.dt_to_ts(dt=_now_local_dt)\n    logger.info(f\"Converted local datetime to UTC timestamp (seconds): {_dt_ts}\")\n\n    _replaced_tz_dt = dt_utils.replace_tz(dt=_now_local_dt, tz=\"Asia/Ulaanbaatar\")\n    logger.info(f\"Add or replace timezone with Asia/Ulaanbaatar: {_replaced_tz_dt}\")\n\n    _converted_dt = dt_utils.convert_tz(dt=_now_ny_dt, tz=\"Asia/Seoul\")\n    logger.info(\n        f\"Calculated and converted timezone from New York to Seoul: {_converted_dt}\"\n    )\n\n    _dt_iso = dt_utils.dt_to_iso(dt=_now_local_dt)\n    logger.info(f\"Parsing datetime to ISO 8601 format string: {_dt_iso}\")\n\n    _future_dt = dt_utils.calc_future_dt(delta=3600, dt=_now_local_dt, tz=\"Asia/Tokyo\")\n    logger.info(f\"Calculated future datetime after 3600 seconds in Tokyo: {_future_dt}\")\n    logger.info(\"-\" * 80)\n\n    # Generator utils:\n    logger.info(\"[GENERATOR UTILITIES]\")\n    _unique_id = gen_utils.gen_unique_id(prefix=\"item_\")\n    logger.info(f\"Generated unique ID based on datetime and UUIDv4: {_unique_id}\")\n\n    _random_str = gen_utils.gen_random_string(length=32, is_alphanum=False)\n    logger.info(f\"Generated secure random string: {_random_str}\")\n    logger.info(\"-\" * 80)\n\n    # Sanitizer utils:\n    logger.info(\"[SANITIZER UTILITIES]\")\n    _raw_html = '  &lt;script&gt;alert(\"XSS Attack!\");&lt;/script&gt;  '\n    _escaped_html = sanitizer_utils.escape_html(val=_raw_html)\n    logger.info(f\"Escaped HTML: {_escaped_html}\")\n\n    _raw_url = \"https://www.example.com/search?q=potato util&amp;body=&lt;script&gt;alert('Attack!')&lt;/script&gt;&amp;lang=\ud55c\uad6d\uc5b4\"\n    _escaped_url = sanitizer_utils.escape_url(val=_raw_url)\n    logger.info(f\"Escaped URL: {_escaped_url}\")\n\n    _raw_str = \"Hello@World! This is a test_string with special#chars$%&amp;*()[]{};:'\\\",.&lt;&gt;?/\\\\|`~\"\n    _sanitized_str = sanitizer_utils.sanitize_special_chars(val=_raw_str, mode=\"STRICT\")\n    logger.info(f\"Sanitized string: {_sanitized_str}\")\n    logger.info(\"-\" * 80)\n\n    # Secure utils:\n    logger.info(\"[SECURE UTILITIES]\")\n    _input_str = \"SensitiveInformation123!\"\n    _hashed_str_sha256 = secure_utils.hash_str(val=_input_str, algorithm=\"sha256\")\n    logger.info(f\"SHA-256 hashed string: {_hashed_str_sha256}\")\n    logger.info(\"-\" * 80)\n\n    # Validator utils:\n    logger.info(\"[VALIDATOR UTILITIES]\")\n    _is_yes_truthy = validator_utils.is_truthy(val=\"Yes\")\n    logger.info(f\"Is 'Yes' truthy: {_is_yes_truthy}\")\n    _is_off_truthy = validator_utils.is_truthy(val=\"OFF\")\n    logger.info(f\"Is 'OFF' truthy: {_is_off_truthy}\")\n\n    _is_no_falsy = validator_utils.is_falsy(val=\"f\")\n    logger.info(f\"Is 'f' falsy: {_is_no_falsy}\")\n    _is_1_falsy = validator_utils.is_falsy(val=\"1\")\n    logger.info(f\"Is '1' falsy: {_is_1_falsy}\")\n\n    _request_id = \"f058ebd6-02f7-4d3f-942e-904344e8cde5\"\n    _is_valid_request_id = validator_utils.is_request_id(val=_request_id)\n    logger.info(f\"Is '{_request_id}' a valid request ID: {_is_valid_request_id}\")\n\n    _blacklist = [\"hacker\", \"guest\"]\n    _input_username = \"hacker\"\n    _is_blacklisted = validator_utils.is_blacklisted(\n        val=_input_username, blacklist=_blacklist\n    )\n    logger.info(f\"Is '{_input_username}' blacklisted: {_is_blacklisted}\")\n\n    _pattern = r\"^[a-zA-Z0-9_]{3,16}$\"  # Alphanumeric and underscores, 3-16 chars\n    _test_username = \"valid_user123\"\n    _is_valid_username = validator_utils.is_valid(val=_test_username, pattern=_pattern)\n    logger.info(f\"Is '{_test_username}' a valid username: {_is_valid_username}\")\n\n    _string_with_special_chars = \"Hello@World!\"\n    _has_special_chars = validator_utils.has_special_chars(\n        val=_string_with_special_chars, mode=\"STRICT\"\n    )\n    logger.info(\n        f\"Does '{_string_with_special_chars}' have special chars: {_has_special_chars}\"\n    )\n    logger.info(\"-\" * 80)\n\n    # HTTP utils:\n    logger.info(\"[HTTP UTILITIES]\")\n    _http_status_tuple = http_utils.get_http_status(status_code=403)\n    logger.info(f\"HTTP status and known: {_http_status_tuple}\")\n\n    _url = AnyHttpUrl(\"https://www.google.com\")\n    _is_connectable = http_utils.is_connectable(url=_url, timeout=3, check_status=True)\n    logger.info(f\"Is '{_url}' connectable: {_is_connectable}\")\n    logger.info(\"-\" * 80)\n\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["getting-started"]},{"location":"getting-started/installation/","title":"\ud83d\udee0 Installation","text":"","tags":["getting-started"]},{"location":"getting-started/installation/#1-download-or-clone-the-repository","title":"1. \ud83d\udce5 Download or clone the repository","text":"<p>[TIP] Skip this step, if you're going to install the package directly from PyPi or GitHub repository.</p> <p>1.1. Prepare projects directory (if not exists):</p> <pre><code># Create projects directory:\nmkdir -pv ~/workspaces/projects\n\n# Enter into projects directory:\ncd ~/workspaces/projects\n</code></pre> <p>1.2. Follow one of the below options [A], [B] or [C]:</p> <p>OPTION A. Clone the repository:</p> <pre><code>git clone https://github.com/bybatkhuu/module-python-utils.git &amp;&amp; \\\n    cd module-python-utils\n</code></pre> <p>OPTION B. Clone the repository (for DEVELOPMENT: git + ssh key):</p> <pre><code>git clone git@github.com:bybatkhuu/module-python-utils.git &amp;&amp; \\\n    cd module-python-utils\n</code></pre> <p>OPTION C. Download source code:</p> <ol> <li>Download archived zip file from releases.</li> <li>Extract it into the projects directory.</li> </ol>","tags":["getting-started"]},{"location":"getting-started/installation/#2-install-the-package","title":"2. \ud83d\udce6 Install the package","text":"<p>[NOTE] Choose one of the following methods to install the package [A ~ F]:</p> <p>OPTION A. [RECOMMENDED] Install from PyPi:</p> <pre><code>pip install -U potato-util\n</code></pre> <p>OPTION B. Install latest version directly from GitHub repository:</p> <pre><code>pip install git+https://github.com/bybatkhuu/module-python-utils.git\n</code></pre> <p>OPTION C. Install from the downloaded source code:</p> <pre><code># Install directly from the source code:\npip install .\n\n# Or install with editable mode:\npip install -e .\n</code></pre> <p>OPTION D. Install for DEVELOPMENT environment:</p> <pre><code>pip install -e .[dev]\n\n# Install pre-commit hooks:\npre-commit install\n</code></pre> <p>OPTION E. Install from pre-built release files:</p> <ol> <li>Download <code>.whl</code> or <code>.tar.gz</code> file from releases</li> <li>Install with pip:</li> </ol> <pre><code># Install from .whl file:\npip install ./potato_util-[VERSION]-py3-none-any.whl\n\n# Or install from .tar.gz file:\npip install ./potato_util-[VERSION].tar.gz\n</code></pre> <p>OPTION F. Copy the module into the project directory (for testing):</p> <pre><code># Install python dependencies:\npip install -r ./requirements.txt\n\n# Copy the module source code into the project:\ncp -r ./src/potato_util [PROJECT_DIR]\n# For example:\ncp -r ./src/potato_util /some/path/project/\n</code></pre>","tags":["getting-started"]},{"location":"getting-started/prerequisites/","title":"\ud83d\udea7 Prerequisites","text":"<ul> <li>Install Python (&gt;= v3.10) and pip (&gt;= 23):<ul> <li>[RECOMMENDED]  Miniconda (v3)</li> <li>[arm64/aarch64]  Miniforge (v3)</li> <li>[Python virutal environment]  venv</li> </ul> </li> </ul> <p>[OPTIONAL] For DEVELOPMENT environment:</p> <ul> <li>Install git</li> <li>Setup an SSH key</li> </ul>","tags":["getting-started"]}]}